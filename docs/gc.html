<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>JVM/Julia Garbage Collection Integration</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">libjulia-clj</span> <span class="project-version">0.07</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="gc.html"><div class="inner"><span>JVM/Julia Garbage Collection Integration</span></div></a></li><li class="depth-1 "><a href="signals.html"><div class="inner"><span>Julia, The JVM, and Signals</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>libjulia-clj</span></div></div></li><li class="depth-2 branch"><a href="libjulia-clj.julia.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>julia</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>modules</span></div></div></li><li class="depth-3 branch"><a href="libjulia-clj.modules.Base.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>Base</span></div></a></li><li class="depth-3 branch"><a href="libjulia-clj.modules.Core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>Core</span></div></a></li><li class="depth-3 branch"><a href="libjulia-clj.modules.DifferentialEquations.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>DifferentialEquations</span></div></a></li><li class="depth-3"><a href="libjulia-clj.modules.LinearAlgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>LinearAlgebra</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#jvm-julia-garbage-collection-integration" name="jvm-julia-garbage-collection-integration"></a>JVM/Julia Garbage Collection Integration</h1>
<p>Both the JVM and julia rely on garbage collection in order to decided when and how to cleanup objects. This means that we need a mechanism to ensure that objects visible across language boundaries are not cleaned up prematurely.</p>
<h2><a href="#julia-objects-in-the-jvm" name="julia-objects-in-the-jvm"></a>Julia Objects in the JVM</h2>
<p>When a new julia object is returned from a function we first check if this is a primitive or atomic type - numbers, symbols, strings. If so, we convert the value into the JVM immediately. Else we return a JVM object and <code>root</code> the julia object in a datastructure we declared to julia.</p>
<p>The user has a choice to link the Julia object to the JVM’s GC mechanism such that when the JVM decided the object is no longer reachable we will then unroot the Julia object. This is default and requires the user to periodically call <a href="https://github.com/cnuernber/libjulia-clj/blob/4bf826aa9651c848985e8e13c5d392db4da26d69/src/libjulia_clj/julia.clj#L112"><code>cycle-gc!</code></a> in order to unroot objects as the JVM’s callback happens in another thread and thus we can only mark objects that should be unrooted automatically. The gc based unrooting needs to be cooperative at this point to ensure it happens in whichever thread is currently using Julia.</p>
<p>There is also a stack based mechanism, <a href="https://github.com/cnuernber/libjulia-clj/blob/4bf826aa9651c848985e8e13c5d392db4da26d69/src/libjulia_clj/julia.clj#L123"><code>with-stack-context</code></a> by which we can ensure that Julia objects rooted within a given stack scope are unrooted when programmatic flow exits that scope either normally or via an exception.</p>
<h2><a href="#jvm-objects-in-julia" name="jvm-objects-in-julia"></a>JVM Objects in Julia</h2>
<ul>
  <li>TODO - not sure if this is very necessary or the best way to handle this. Currently you can pass functions to Julia but this isn’t very fleshed out and it is most likely not bullet-proof. If they are called from tasks then there is a decent chance they will be silently ignored. Most likely you, from the JVM side, will need to ensure they do not leave JVM scope while you think they are in scope in Julia.</li>
</ul></div></div></div></body></html>