<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>libjulia-clj.modules.LinearAlgebra documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">libjulia-clj</span> <span class="project-version">0.05</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="signals.html"><div class="inner"><span>Julia, The JVM, and Signals</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>libjulia-clj</span></div></div></li><li class="depth-2 branch"><a href="libjulia-clj.julia.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>julia</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>modules</span></div></div></li><li class="depth-3 branch"><a href="libjulia-clj.modules.Base.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>Base</span></div></a></li><li class="depth-3 branch"><a href="libjulia-clj.modules.Core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>Core</span></div></a></li><li class="depth-3 branch"><a href="libjulia-clj.modules.DifferentialEquations.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>DifferentialEquations</span></div></a></li><li class="depth-3 current"><a href="libjulia-clj.modules.LinearAlgebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>LinearAlgebra</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-.2F"><div class="inner"><span>/</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-.5C"><div class="inner"><span>\</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Adjoint"><div class="inner"><span>Adjoint</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-adjoint"><div class="inner"><span>adjoint</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-adjoint.21"><div class="inner"><span>adjoint!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-axpby.21"><div class="inner"><span>axpby!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-axpy.21"><div class="inner"><span>axpy!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Bidiagonal"><div class="inner"><span>Bidiagonal</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-BLAS"><div class="inner"><span>BLAS</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-BunchKaufman"><div class="inner"><span>BunchKaufman</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-bunchkaufman"><div class="inner"><span>bunchkaufman</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-bunchkaufman.21"><div class="inner"><span>bunchkaufman!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Cholesky"><div class="inner"><span>Cholesky</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-cholesky"><div class="inner"><span>cholesky</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-cholesky.21"><div class="inner"><span>cholesky!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-CholeskyPivoted"><div class="inner"><span>CholeskyPivoted</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-cond"><div class="inner"><span>cond</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-condskeel"><div class="inner"><span>condskeel</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-copy_transpose.21"><div class="inner"><span>copy_transpose!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-copyto.21"><div class="inner"><span>copyto!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-cross"><div class="inner"><span>cross</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-det"><div class="inner"><span>det</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-diag"><div class="inner"><span>diag</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-diagind"><div class="inner"><span>diagind</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-diagm"><div class="inner"><span>diagm</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Diagonal"><div class="inner"><span>Diagonal</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Eigen"><div class="inner"><span>Eigen</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigen"><div class="inner"><span>eigen</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigen.21"><div class="inner"><span>eigen!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigmax"><div class="inner"><span>eigmax</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigmin"><div class="inner"><span>eigmin</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigvals"><div class="inner"><span>eigvals</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigvals.21"><div class="inner"><span>eigvals!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-eigvecs"><div class="inner"><span>eigvecs</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Factorization"><div class="inner"><span>Factorization</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-factorize"><div class="inner"><span>factorize</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-GeneralizedEigen"><div class="inner"><span>GeneralizedEigen</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-GeneralizedSchur"><div class="inner"><span>GeneralizedSchur</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-GeneralizedSVD"><div class="inner"><span>GeneralizedSVD</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-givens"><div class="inner"><span>givens</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Hermitian"><div class="inner"><span>Hermitian</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Hessenberg"><div class="inner"><span>Hessenberg</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-hessenberg"><div class="inner"><span>hessenberg</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-hessenberg.21"><div class="inner"><span>hessenberg!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-I"><div class="inner"><span>I</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-isdiag"><div class="inner"><span>isdiag</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ishermitian"><div class="inner"><span>ishermitian</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-isposdef"><div class="inner"><span>isposdef</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-isposdef.21"><div class="inner"><span>isposdef!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-issuccess"><div class="inner"><span>issuccess</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-issymmetric"><div class="inner"><span>issymmetric</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-istril"><div class="inner"><span>istril</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-istriu"><div class="inner"><span>istriu</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-kron"><div class="inner"><span>kron</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LAPACK"><div class="inner"><span>LAPACK</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LAPACKException"><div class="inner"><span>LAPACKException</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ldiv.21"><div class="inner"><span>ldiv!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LDLt"><div class="inner"><span>LDLt</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ldlt"><div class="inner"><span>ldlt</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ldlt.21"><div class="inner"><span>ldlt!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LinearAlgebra"><div class="inner"><span>LinearAlgebra</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lmul.21"><div class="inner"><span>lmul!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-logabsdet"><div class="inner"><span>logabsdet</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-logdet"><div class="inner"><span>logdet</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LowerTriangular"><div class="inner"><span>LowerTriangular</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lowrankdowndate"><div class="inner"><span>lowrankdowndate</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lowrankdowndate.21"><div class="inner"><span>lowrankdowndate!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lowrankupdate"><div class="inner"><span>lowrankupdate</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lowrankupdate.21"><div class="inner"><span>lowrankupdate!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LQ"><div class="inner"><span>LQ</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lq"><div class="inner"><span>lq</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lq.21"><div class="inner"><span>lq!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-LU"><div class="inner"><span>LU</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lu"><div class="inner"><span>lu</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lu.21"><div class="inner"><span>lu!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-lyap"><div class="inner"><span>lyap</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-module"><div class="inner"><span>module</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-mul.21"><div class="inner"><span>mul!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-norm"><div class="inner"><span>norm</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-normalize"><div class="inner"><span>normalize</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-normalize.21"><div class="inner"><span>normalize!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-nullspace"><div class="inner"><span>nullspace</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-opnorm"><div class="inner"><span>opnorm</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ordschur"><div class="inner"><span>ordschur</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ordschur.21"><div class="inner"><span>ordschur!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-pinv"><div class="inner"><span>pinv</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-PosDefException"><div class="inner"><span>PosDefException</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-QR"><div class="inner"><span>QR</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-qr"><div class="inner"><span>qr</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-qr.21"><div class="inner"><span>qr!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-QRPivoted"><div class="inner"><span>QRPivoted</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-rank"><div class="inner"><span>rank</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-RankDeficientException"><div class="inner"><span>RankDeficientException</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-rdiv.21"><div class="inner"><span>rdiv!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-reflect.21"><div class="inner"><span>reflect!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-rmul.21"><div class="inner"><span>rmul!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-rotate.21"><div class="inner"><span>rotate!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Schur"><div class="inner"><span>Schur</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-schur"><div class="inner"><span>schur</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-schur.21"><div class="inner"><span>schur!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-SingularException"><div class="inner"><span>SingularException</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-SVD"><div class="inner"><span>SVD</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-svd"><div class="inner"><span>svd</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-svd.21"><div class="inner"><span>svd!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-svdvals"><div class="inner"><span>svdvals</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-svdvals.21"><div class="inner"><span>svdvals!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-sylvester"><div class="inner"><span>sylvester</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Symmetric"><div class="inner"><span>Symmetric</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-SymTridiagonal"><div class="inner"><span>SymTridiagonal</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-tr"><div class="inner"><span>tr</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Transpose"><div class="inner"><span>Transpose</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-transpose"><div class="inner"><span>transpose</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-transpose.21"><div class="inner"><span>transpose!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-Tridiagonal"><div class="inner"><span>Tridiagonal</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-tril"><div class="inner"><span>tril</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-tril.21"><div class="inner"><span>tril!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-triu"><div class="inner"><span>triu</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-triu.21"><div class="inner"><span>triu!</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-UniformScaling"><div class="inner"><span>UniformScaling</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-UnitLowerTriangular"><div class="inner"><span>UnitLowerTriangular</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-UnitUpperTriangular"><div class="inner"><span>UnitUpperTriangular</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-UpperHessenberg"><div class="inner"><span>UpperHessenberg</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-UpperTriangular"><div class="inner"><span>UpperTriangular</span></div></a></li><li class="depth-1"><a href="libjulia-clj.modules.LinearAlgebra.html#var-ZeroPivotException"><div class="inner"><span>ZeroPivotException</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">libjulia-clj.modules.LinearAlgebra</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-.2F"><h3>/</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>/(x, y)
</code></pre>
<p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; 1/2
0.5

julia&gt; 4/2
2.0

julia&gt; 4.5/2
2.25
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-.5C"><h3>\</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>\(x, y)
</code></pre>
<p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [4 3; 2 1]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
  6.5
 -7.0

julia&gt; inv(A) * x
2-element Array{Float64,1}:
  6.5
 -7.0
</code></pre>
<pre><code>\(A, B)
</code></pre>
<p>Matrix division using a polyalgorithm. For input matrices <code>A</code> and <code>B</code>, the result <code>X</code> is such that <code>A*X == B</code> when <code>A</code> is square. The solver that is used depends upon the structure of <code>A</code>. If <code>A</code> is upper or lower triangular (or diagonal), no factorization of <code>A</code> is required and the system is solved with either forward or backward substitution. For non-triangular square matrices, an LU factorization is used.</p>
<p>For rectangular <code>A</code> the result is the minimum-norm least squares solution computed by a pivoted QR factorization of <code>A</code> and a rank estimate of <code>A</code> based on the R factor.</p>
<p>When <code>A</code> is sparse, a similar polyalgorithm is used. For indefinite matrices, the <code>LDLt</code> factorization does not use pivoting during the numerical factorization and therefore the procedure can fail even for invertible matrices.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0; 1 -2]; B = [32; -4];

julia&gt; X = A \ B
2-element Array{Float64,1}:
 32.0
 18.0

julia&gt; A * X == B
true
</code></pre>
<pre><code>(\)(F::QRSparse, B::StridedVecOrMat)
</code></pre>
<p>Solve the least squares problem $\min|Ax - b|^2$ or the linear system of equations $Ax=b$ when <code>F</code> is the sparse QR factorization of $A$. A basic solution is returned when the problem is underdetermined.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = sparse([1,2,4], [1,1,1], [1.0,1.0,1.0], 4, 2)
4×2 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [4, 1]  =  1.0

julia&gt; qr(A)\fill(1.0, 4)
2-element Array{Float64,1}:
 1.0
 0.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Adjoint"><h3>Adjoint</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Adjoint
</code></pre>
<p>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an <code>AbstractVector</code>/<code>AbstractMatrix</code>, but also some <code>Factorization</code>, for instance. Usually, the <code>Adjoint</code> constructor should not be called directly, use <a href="@ref"><code>adjoint</code></a> instead. To materialize the view use <a href="@ref"><code>copy</code></a>.</p>
<p>This type is intended for linear algebra usage - for general data manipulation see [<code>permutedims</code>](@ref Base.permutedims).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-adjoint"><h3>adjoint</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>A'
adjoint(A)
</code></pre>
<p>Lazy adjoint (conjugate transposition). Note that <code>adjoint</code> is applied recursively to elements.</p>
<p>For number types, <code>adjoint</code> returns the complex conjugate, and therefore it is equivalent to the identity function for real numbers.</p>
<p>This operation is intended for linear algebra usage - for general data manipulation see [<code>permutedims</code>](@ref Base.permutedims).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; adjoint(A)
2×2 Adjoint{Complex{Int64},Array{Complex{Int64},2}}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; x = [3, 4im]
2-element Array{Complex{Int64},1}:
 3 + 0im
 0 + 4im

julia&gt; x'x
25 + 0im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-adjoint.21"><h3>adjoint!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>adjoint!(dest,src)
</code></pre>
<p>Conjugate transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; adjoint!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3-2im  8-7im
 9-2im  4-6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-axpby.21"><h3>axpby!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>axpby!(a, X, b, Y)
</code></pre>
<p>Overwrite <code>Y</code> with <code>X*a + Y*b</code>, where <code>a</code> and <code>b</code> are scalars. Return <code>Y</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; x = [1., 2, 3];

julia&gt; y = [4., 5, 6];

julia&gt; BLAS.axpby!(2., x, 3., y)
3-element Array{Float64,1}:
 14.0
 19.0
 24.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-axpy.21"><h3>axpy!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>axpy!(a, X, Y)
</code></pre>
<p>Overwrite <code>Y</code> with <code>X*a + Y</code>, where <code>a</code> is a scalar. Return <code>Y</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; x = [1; 2; 3];

julia&gt; y = [4; 5; 6];

julia&gt; BLAS.axpy!(2, x, y)
3-element Array{Int64,1}:
  6
  9
 12
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Bidiagonal"><h3>Bidiagonal</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Bidiagonal(dv::V, ev::V, uplo::Symbol) where V &lt;: AbstractVector
</code></pre>
<p>Constructs an upper (<code>uplo=:U</code>) or lower (<code>uplo=:L</code>) bidiagonal matrix using the given diagonal (<code>dv</code>) and off-diagonal (<code>ev</code>) vectors. The result is of type <code>Bidiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="@ref"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The length of <code>ev</code> must be one less than the length of <code>dv</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; Bu = Bidiagonal(dv, ev, :U) # ev is on the first superdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 ⋅  2  8  ⋅
 ⋅  ⋅  3  9
 ⋅  ⋅  ⋅  4

julia&gt; Bl = Bidiagonal(dv, ev, :L) # ev is on the first subdiagonal
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 7  2  ⋅  ⋅
 ⋅  8  3  ⋅
 ⋅  ⋅  9  4
</code></pre>
<pre><code>Bidiagonal(A, uplo::Symbol)
</code></pre>
<p>Construct a <code>Bidiagonal</code> matrix from the main diagonal of <code>A</code> and its first super- (if <code>uplo=:U</code>) or sub-diagonal (if <code>uplo=:L</code>).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 1 1 1; 2 2 2 2; 3 3 3 3; 4 4 4 4]
4×4 Array{Int64,2}:
 1  1  1  1
 2  2  2  2
 3  3  3  3
 4  4  4  4

julia&gt; Bidiagonal(A, :U) # contains the main diagonal and first superdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  1  ⋅  ⋅
 ⋅  2  2  ⋅
 ⋅  ⋅  3  3
 ⋅  ⋅  ⋅  4

julia&gt; Bidiagonal(A, :L) # contains the main diagonal and first subdiagonal of A
4×4 Bidiagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅  ⋅
 2  2  ⋅  ⋅
 ⋅  3  3  ⋅
 ⋅  ⋅  4  4
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-BLAS"><h3>BLAS</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Interface to BLAS subroutines.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-BunchKaufman"><h3>BunchKaufman</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>BunchKaufman &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the Bunch-Kaufman factorization of a symmetric or Hermitian matrix <code>A</code> as <code>P'UDU'P</code> or <code>P'LDL'P</code>, depending on whether the upper (the default) or the lower triangle is stored in <code>A</code>. If <code>A</code> is complex symmetric then <code>U'</code> and <code>L'</code> denote the unconjugated transposes, i.e. <code>transpose(U)</code> and <code>transpose(L)</code>, respectively. This is the return type of <a href="@ref"><code>bunchkaufman</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>S::BunchKaufman</code> is the factorization object, the components can be obtained via <code>S.D</code>, <code>S.U</code> or <code>S.L</code> as appropriate given <code>S.uplo</code>, and <code>S.p</code>.</p>
<p>Iterating the decomposition produces the components <code>S.D</code>, <code>S.U</code> or <code>S.L</code> as appropriate given <code>S.uplo</code>, and <code>S.p</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia&gt; S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia&gt; d, u, p = S; # destructuring via iteration

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true

julia&gt; S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-bunchkaufman"><h3>bunchkaufman</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>bunchkaufman(A, rook::Bool=false; check = true) -&gt; S::BunchKaufman
</code></pre>
<p>Compute the Bunch-Kaufman [^Bunch1977] factorization of a symmetric or Hermitian matrix <code>A</code> as <code>P'*U*D*U'*P</code> or <code>P'*L*D*L'*P</code>, depending on which triangle is stored in <code>A</code>, and return a <a href="@ref"><code>BunchKaufman</code></a> object. Note that if <code>A</code> is complex symmetric then <code>U'</code> and <code>L'</code> denote the unconjugated transposes, i.e. <code>transpose(U)</code> and <code>transpose(L)</code>.</p>
<p>Iterating the decomposition produces the components <code>S.D</code>, <code>S.U</code> or <code>S.L</code> as appropriate given <code>S.uplo</code>, and <code>S.p</code>.</p>
<p>If <code>rook</code> is <code>true</code>, rook pivoting is used. If <code>rook</code> is false, rook pivoting is not used.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>The following functions are available for <code>BunchKaufman</code> objects: <a href="@ref"><code>size</code></a>, <code>\</code>, <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>issymmetric</code></a>, <a href="@ref"><code>ishermitian</code></a>, <a href="@ref"><code>getindex</code></a>.</p>
<p>[^Bunch1977]: J R Bunch and L Kaufman, Some stable methods for calculating inertia and solving symmetric linear systems, Mathematics of Computation 31:137 (1977), 163-179. <a href="http://www.ams.org/journals/mcom/1977-31-137/S0025-5718-1977-0428694-0/">url</a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 2 3]
2×2 Array{Int64,2}:
 1  2
 2  3

julia&gt; S = bunchkaufman(A) # A gets wrapped internally by Symmetric(A)
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 -0.333333  0.0
  0.0       3.0
U factor:
2×2 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  0.666667
  ⋅   1.0
permutation:
2-element Array{Int64,1}:
 1
 2

julia&gt; d, u, p = S; # destructuring via iteration

julia&gt; d == S.D &amp;&amp; u == S.U &amp;&amp; p == S.p
true

julia&gt; S = bunchkaufman(Symmetric(A, :L))
BunchKaufman{Float64,Array{Float64,2}}
D factor:
2×2 Tridiagonal{Float64,Array{Float64,1}}:
 3.0   0.0
 0.0  -0.333333
L factor:
2×2 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0        ⋅
 0.666667  1.0
permutation:
2-element Array{Int64,1}:
 2
 1
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-bunchkaufman.21"><h3>bunchkaufman!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>bunchkaufman!(A, rook::Bool=false; check = true) -&gt; BunchKaufman
</code></pre>
<p><code>bunchkaufman!</code> is the same as <a href="@ref"><code>bunchkaufman</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Cholesky"><h3>Cholesky</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Cholesky &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the Cholesky factorization of a dense symmetric/Hermitian positive definite matrix <code>A</code>. This is the return type of <a href="@ref"><code>cholesky</code></a>, the corresponding matrix factorization function.</p>
<p>The triangular Cholesky factor can be obtained from the factorization <code>F::Cholesky</code> via <code>F.L</code> and <code>F.U</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-cholesky"><h3>cholesky</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>cholesky(A, Val(false); check = true) -&gt; Cholesky
</code></pre>
<p>Compute the Cholesky factorization of a dense symmetric positive definite matrix <code>A</code> and return a <a href="@ref"><code>Cholesky</code></a> factorization. The matrix <code>A</code> can either be a <a href="@ref"><code>Symmetric</code></a> or <a href="@ref"><code>Hermitian</code></a> <a href="@ref"><code>StridedMatrix</code></a> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>Cholesky</code> objects: <a href="@ref"><code>size</code></a>, <a href="@ref"><code>\</code></a>, <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, <a href="@ref"><code>logdet</code></a> and <a href="@ref"><code>isposdef</code></a>.</p>
<p>If you have a matrix <code>A</code> that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in <code>Hermitian(A)</code> before passing it to <code>cholesky</code> in order to treat it as perfectly Hermitian.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A)
Cholesky{Float64,Array{Float64,2}}
U factor:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.U
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 2.0  6.0  -8.0
  ⋅   1.0   5.0
  ⋅    ⋅    3.0

julia&gt; C.L
3×3 LowerTriangular{Float64,Array{Float64,2}}:
  2.0   ⋅    ⋅
  6.0  1.0   ⋅
 -8.0  5.0  3.0

julia&gt; C.L * C.U == A
true
</code></pre>
<pre><code>cholesky(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted
</code></pre>
<p>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix <code>A</code> and return a <a href="@ref"><code>CholeskyPivoted</code></a> factorization. The matrix <code>A</code> can either be a <a href="@ref"><code>Symmetric</code></a> or <a href="@ref"><code>Hermitian</code></a> <a href="@ref"><code>StridedMatrix</code></a> or a <em>perfectly</em> symmetric or Hermitian <code>StridedMatrix</code>. The triangular Cholesky factor can be obtained from the factorization <code>F</code> with: <code>F.L</code> and <code>F.U</code>. The following functions are available for <code>CholeskyPivoted</code> objects: <a href="@ref"><code>size</code></a>, <a href="@ref"><code>\</code></a>, <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>rank</code></a>. The argument <code>tol</code> determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</p>
<p>If you have a matrix <code>A</code> that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in <code>Hermitian(A)</code> before passing it to <code>cholesky</code> in order to treat it as perfectly Hermitian.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<pre><code>cholesky(A; shift = 0.0, check = true, perm = nothing) -&gt; CHOLMOD.Factor
</code></pre>
<p>Compute the Cholesky factorization of a sparse positive definite matrix <code>A</code>. <code>A</code> must be a <a href="@ref"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/<a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn’t have the type tag, it must still be symmetric or Hermitian. If <code>perm</code> is not given, a fill-reducing permutation is used. <code>F = cholesky(A)</code> is most frequently used to solve systems of equations with <code>F\b</code>, but also the methods <a href="@ref"><code>diag</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>logdet</code></a> are defined for <code>F</code>. You can also extract individual factors from <code>F</code>, using <code>F.L</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P'*L*L'*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it’s typically preferable to extract “combined” factors like <code>PtL = F.PtL</code> (the equivalent of <code>P'*L</code>) and <code>LtP = F.UP</code> (the equivalent of <code>L'*P</code>).</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is provided, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD’s default AMD ordering).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<p>In the following example, the fill-reducing permutation used is <code>[3, 2, 1]</code>. If <code>perm</code> is set to <code>1:3</code> to enforce no permutation, the number of nonzero elements in the factor is 6.</p>
<pre><code class="jldoctest">julia&gt; A = [2 1 1; 1 2 0; 1 0 2]
3×3 Array{Int64,2}:
 2  1  1
 1  2  0
 1  0  2

julia&gt; C = cholesky(sparse(A))
SuiteSparse.CHOLMOD.Factor{Float64}
type:    LLt
method:  simplicial
maxnnz:  5
nnz:     5
success: true

julia&gt; C.p
3-element Array{Int64,1}:
 3
 2
 1

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Array{Float64,2}:
 1.41421   0.0       0.0
 0.0       1.41421   0.0
 0.707107  0.707107  1.0

julia&gt; L * L' ≈ A[C.p, C.p]
true

julia&gt; P = sparse(1:3, C.p, ones(3))
3×3 SparseMatrixCSC{Float64,Int64} with 3 stored entries:
  [3, 1]  =  1.0
  [2, 2]  =  1.0
  [1, 3]  =  1.0

julia&gt; P' * L * L' * P ≈ A
true

julia&gt; C = cholesky(sparse(A), perm=1:3)
SuiteSparse.CHOLMOD.Factor{Float64}
type:    LLt
method:  simplicial
maxnnz:  6
nnz:     6
success: true

julia&gt; L = sparse(C.L);

julia&gt; Matrix(L)
3×3 Array{Float64,2}:
 1.41421    0.0       0.0
 0.707107   1.22474   0.0
 0.707107  -0.408248  1.1547

julia&gt; L * L' ≈ A
true
</code></pre>
<p>!!! note  This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p>
<pre><code>Many other functions from CHOLMOD are wrapped but not exported from the `Base.SparseArrays.CHOLMOD` module.
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-cholesky.21"><h3>cholesky!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>cholesky!(A, Val(false); check = true) -&gt; Cholesky
</code></pre>
<p>The same as <a href="@ref"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="@ref"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; cholesky!(A)
ERROR: InexactError: Int64(6.782329983125268)
Stacktrace:
[...]
</code></pre>
<pre><code>cholesky!(A, Val(true); tol = 0.0, check = true) -&gt; CholeskyPivoted
</code></pre>
<p>The same as <a href="@ref"><code>cholesky</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="@ref"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<pre><code>cholesky!(F::Factor, A; shift = 0.0, check = true) -&gt; CHOLMOD.Factor
</code></pre>
<p>Compute the Cholesky ($LL’$) factorization of <code>A</code>, reusing the symbolic factorization <code>F</code>. <code>A</code> must be a <a href="@ref"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/ <a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn’t have the type tag, it must still be symmetric or Hermitian.</p>
<p>See also <a href="@ref"><code>cholesky</code></a>.</p>
<p>!!! note  This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-CholeskyPivoted"><h3>CholeskyPivoted</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>CholeskyPivoted
</code></pre>
<p>Matrix factorization type of the pivoted Cholesky factorization of a dense symmetric/Hermitian positive semi-definite matrix <code>A</code>. This is the return type of <a href="@ref"><code>cholesky(_, Val(true))</code></a>, the corresponding matrix factorization function.</p>
<p>The triangular Cholesky factor can be obtained from the factorization <code>F::CholeskyPivoted</code> via <code>F.L</code> and <code>F.U</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4. 12. -16.; 12. 37. -43.; -16. -43. 98.]
3×3 Array{Float64,2}:
   4.0   12.0  -16.0
  12.0   37.0  -43.0
 -16.0  -43.0   98.0

julia&gt; C = cholesky(A, Val(true))
CholeskyPivoted{Float64,Array{Float64,2}}
U factor with rank 3:
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 9.89949  -4.34366  -1.61624
  ⋅        4.25825   1.1694
  ⋅         ⋅        0.142334
permutation:
3-element Array{Int64,1}:
 3
 2
 1
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-cond"><h3>cond</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>cond(M, p::Real=2)
</code></pre>
<p>Condition number of the matrix <code>M</code>, computed using the operator <code>p</code>-norm. Valid values for <code>p</code> are <code>1</code>, <code>2</code> (default), or <code>Inf</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-condskeel"><h3>condskeel</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>condskeel(M, [x, p::Real=Inf])
</code></pre>
<p>$$ \kappa_S(M, p) = \left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \right\Vert_p \ \kappa_S(M, x, p) = \frac{\left\Vert \left\vert M \right\vert \left\vert M^{-1} \right\vert \left\vert x \right\vert \right\Vert_p}{\left \Vert x \right \Vert_p} $$</p>
<p>Skeel condition number $\kappa_S$ of the matrix <code>M</code>, optionally with respect to the vector <code>x</code>, as computed using the operator <code>p</code>-norm. $\left\vert M \right\vert$ denotes the matrix of (entry wise) absolute values of $M$; $\left\vert M \right\vert_{ij} = \left\vert M_{ij} \right\vert$. Valid values for <code>p</code> are <code>1</code>, <code>2</code> and <code>Inf</code> (default).</p>
<p>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-copy_transpose.21"><h3>copy_transpose!</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>No documentation found.</p>
<p><code>LinearAlgebra.copy_transpose!</code> is a <code>Function</code>.</p>
<pre><code># 2 methods for generic function "copy_transpose!":
[1] copy_transpose!(B::Union{AbstractArray{T,1}, AbstractArray{T,2}} where T, ir_dest::AbstractRange{Int64}, jr_dest::AbstractRange{Int64}, A::Union{AbstractArray{T,1}, AbstractArray{T,2}} where T, ir_src::AbstractRange{Int64}, jr_src::AbstractRange{Int64}) in LinearAlgebra at /home/chrisn/dev/cnuernber/libjulia-clj/julia-1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/transpose.jl:181
[2] copy_transpose!(B::AbstractArray{T,2} where T, ir_dest::UnitRange{Int64}, jr_dest::UnitRange{Int64}, tM::AbstractChar, M::Union{AbstractArray{T,1}, AbstractArray{T,2}} where T, ir_src::UnitRange{Int64}, jr_src::UnitRange{Int64}) in LinearAlgebra at /home/chrisn/dev/cnuernber/libjulia-clj/julia-1.5.3/share/julia/stdlib/v1.5/LinearAlgebra/src/matmul.jl:617
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-copyto.21"><h3>copyto!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>copyto!(dest, do, src, so, N)
</code></pre>
<p>Copy <code>N</code> elements from collection <code>src</code> starting at offset <code>so</code>, to array <code>dest</code> starting at offset <code>do</code>. Return <code>dest</code>.</p>
<pre><code>copyto!(dest::AbstractArray, src) -&gt; dest
</code></pre>
<p>Copy all elements from collection <code>src</code> to array <code>dest</code>, whose length must be greater than or equal to the length <code>n</code> of <code>src</code>. The first <code>n</code> elements of <code>dest</code> are overwritten, the other elements are left untouched.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; x = [1., 0., 3., 0., 5.];

julia&gt; y = zeros(7);

julia&gt; copyto!(y, x);

julia&gt; y
7-element Array{Float64,1}:
 1.0
 0.0
 3.0
 0.0
 5.0
 0.0
 0.0
</code></pre>
<pre><code>copyto!(dest, Rdest::CartesianIndices, src, Rsrc::CartesianIndices) -&gt; dest
</code></pre>
<p>Copy the block of <code>src</code> in the range of <code>Rsrc</code> to the block of <code>dest</code> in the range of <code>Rdest</code>. The sizes of the two regions must match.</p>
<pre><code>copyto!(dest::AbstractMatrix, src::UniformScaling)
</code></pre>
<p>Copies a <a href="@ref"><code>UniformScaling</code></a> onto a matrix.</p>
<p>!!! compat “Julia 1.1”  In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-cross"><h3>cross</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>cross(x, y)
×(x,y)
</code></pre>
<p>Compute the cross product of two 3-vectors.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [0;1;0]
3-element Array{Int64,1}:
 0
 1
 0

julia&gt; b = [0;0;1]
3-element Array{Int64,1}:
 0
 0
 1

julia&gt; cross(a,b)
3-element Array{Int64,1}:
 1
 0
 0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-det"><h3>det</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>det(M)
</code></pre>
<p>Matrix determinant.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; det(M)
2.0
</code></pre>
<pre><code>det(M::Generic.MatrixElem{T}) where {T &lt;: FieldElement}
</code></pre>
<p>Return the determinant of the matrix $M$. We assume $M$ is square.</p>
<pre><code>det(M::Generic.MatrixElem{T}) where {T &lt;: RingElement}
</code></pre>
<p>Return the determinant of the matrix $M$. We assume $M$ is square.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-diag"><h3>diag</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>diag(M, k::Integer=0)
</code></pre>
<p>The <code>k</code>th diagonal of a matrix, as a vector.</p>
<p>See also: <a href="@ref"><code>diagm</code></a></p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diag(A,1)
2-element Array{Int64,1}:
 2
 6
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-diagind"><h3>diagind</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>diagind(M, k::Integer=0)
</code></pre>
<p>An <code>AbstractRange</code> giving the indices of the <code>k</code>th diagonal of the matrix <code>M</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; diagind(A,-1)
2:4:6
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-diagm"><h3>diagm</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>diagm(kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
diagm(m::Integer, n::Integer, kv::Pair{&lt;:Integer,&lt;:AbstractVector}...)
</code></pre>
<p>Construct a matrix from <code>Pair</code>s of diagonals and vectors. Vector <code>kv.second</code> will be placed on the <code>kv.first</code> diagonal. By default the matrix is square and its size is inferred from <code>kv</code>, but a non-square size <code>m</code>×<code>n</code> (padded with zeros as needed) can be specified by passing <code>m,n</code> as the first arguments.</p>
<p><code>diagm</code> constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see <a href="@ref"><code>Diagonal</code></a>, <a href="@ref"><code>Bidiagonal</code></a> <a href="@ref"><code>Tridiagonal</code></a> and <a href="@ref"><code>SymTridiagonal</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; diagm(1 =&gt; [1,2,3])
4×4 Array{Int64,2}:
 0  1  0  0
 0  0  2  0
 0  0  0  3
 0  0  0  0

julia&gt; diagm(1 =&gt; [1,2,3], -1 =&gt; [4,5])
4×4 Array{Int64,2}:
 0  1  0  0
 4  0  2  0
 0  5  0  3
 0  0  0  0
</code></pre>
<pre><code>diagm(v::AbstractVector)
diagm(m::Integer, n::Integer, v::AbstractVector)
</code></pre>
<p>Construct a matrix with elements of the vector as diagonal elements. By default (if <code>size=nothing</code>), the matrix is square and its size is given by <code>length(v)</code>, but a non-square size <code>m</code>×<code>n</code> can be specified by passing <code>m,n</code> as the first arguments.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; diagm([1,2,3])
3×3 Array{Int64,2}:
 1  0  0
 0  2  0
 0  0  3
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Diagonal"><h3>Diagonal</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Diagonal(A::AbstractMatrix)
</code></pre>
<p>Construct a matrix from the diagonal of <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3; 4 5 6; 7 8 9]
3×3 Array{Int64,2}:
 1  2  3
 4  5  6
 7  8  9

julia&gt; Diagonal(A)
3×3 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅  ⋅
 ⋅  5  ⋅
 ⋅  ⋅  9
</code></pre>
<pre><code>Diagonal(V::AbstractVector)
</code></pre>
<p>Construct a matrix with <code>V</code> as its diagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; V = [1, 2]
2-element Array{Int64,1}:
 1
 2

julia&gt; Diagonal(V)
2×2 Diagonal{Int64,Array{Int64,1}}:
 1  ⋅
 ⋅  2
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>dot(x, y)
x ⋅ y
</code></pre>
<p>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.</p>
<p><code>dot</code> also works on arbitrary iterable objects, including arrays of any dimension, as long as <code>dot</code> is defined on the elements.</p>
<p><code>dot</code> is semantically equivalent to <code>sum(dot(vx,vy) for (vx,vy) in zip(x, y))</code>, with the added restriction that the arguments must have equal lengths.</p>
<p><code>x ⋅ y</code> (where <code>⋅</code> can be typed by tab-completing <code>\cdot</code> in the REPL) is a synonym for <code>dot(x, y)</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; dot([1; 1], [2; 3])
5

julia&gt; dot([im; im], [1; 1])
0 - 2im

julia&gt; dot(1:5, 2:6)
70

julia&gt; x = fill(2., (5,5));

julia&gt; y = fill(3., (5,5));

julia&gt; dot(x, y)
150.0
</code></pre>
<pre><code>dot(x, A, y)
</code></pre>
<p>Compute the generalized dot product <code>dot(x, A*y)</code> between two vectors <code>x</code> and <code>y</code>, without storing the intermediate result of <code>A*y</code>. As for the two-argument <a href="@ref"><code>dot(_,_)</code></a>, this acts recursively. Moreover, for complex vectors, the first vector is conjugated.</p>
<p>!!! compat “Julia 1.4”  Three-argument <code>dot</code> requires at least Julia 1.4.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; dot([1; 1], [1 2; 3 4], [2; 3])
26

julia&gt; dot(1:5, reshape(1:25, 5, 5), 2:6)
4850

julia&gt; ⋅(1:5, reshape(1:25, 5, 5), 2:6) == dot(1:5, reshape(1:25, 5, 5), 2:6)
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Eigen"><h3>Eigen</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Eigen &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the eigenvalue/spectral decomposition of a square matrix <code>A</code>. This is the return type of <a href="@ref"><code>eigen</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>F::Eigen</code> is the factorization object, the eigenvalues can be obtained via <code>F.values</code> and the eigenvectors as the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigen"><h3>eigen</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigen(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; Eigen
</code></pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <a href="@ref"><code>Eigen</code></a> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>isposdef</code></a>.</p>
<p>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is <code>true</code> for both options.</p>
<p>By default, the eigenvalues and vectors are sorted lexicographically by <code>(real(λ),imag(λ))</code>. A different comparison function <code>by(λ)</code> can be passed to <code>sortby</code>, or you can pass <code>sortby=nothing</code> to leave the eigenvalues in an arbitrary order. Some special matrix types (e.g. <a href="@ref"><code>Diagonal</code></a> or <a href="@ref"><code>SymTridiagonal</code></a>) may implement their own sorting convention and not accept a <code>sortby</code> keyword.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; F = eigen([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
Eigen{Float64,Float64,Array{Float64,2},Array{Float64,1}}
values:
3-element Array{Float64,1}:
  1.0
  3.0
 18.0
vectors:
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; F.values
3-element Array{Float64,1}:
  1.0
  3.0
 18.0

julia&gt; F.vectors
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true
</code></pre>
<pre><code>eigen(A, B) -&gt; GeneralizedEigen
</code></pre>
<p>Computes the generalized eigenvalue decomposition of <code>A</code> and <code>B</code>, returning a <a href="@ref"><code>GeneralizedEigen</code></a> factorization object <code>F</code> which contains the generalized eigenvalues in <code>F.values</code> and the generalized eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th generalized eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>Any keyword arguments passed to <code>eigen</code> are passed through to the lower-level <a href="@ref"><code>eigen!</code></a> function.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; F = eigen(A, B);

julia&gt; F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true
</code></pre>
<pre><code>eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; Eigen
</code></pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <a href="@ref"><code>Eigen</code></a> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>isposdef</code></a>.</p>
<p>The <a href="@ref"><code>UnitRange</code></a> <code>irange</code> specifies indices of the sorted eigenvalues to search for.</p>
<p>!!! note  If <code>irange</code> is not <code>1:n</code>, where <code>n</code> is the dimension of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p>
<pre><code>eigen(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; Eigen
</code></pre>
<p>Computes the eigenvalue decomposition of <code>A</code>, returning an <a href="@ref"><code>Eigen</code></a> factorization object <code>F</code> which contains the eigenvalues in <code>F.values</code> and the eigenvectors in the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<p>The following functions are available for <code>Eigen</code> objects: <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>det</code></a>, and <a href="@ref"><code>isposdef</code></a>.</p>
<p><code>vl</code> is the lower bound of the window of eigenvalues to search for, and <code>vu</code> is the upper bound.</p>
<p>!!! note  If [<code>vl</code>, <code>vu</code>] does not contain all eigenvalues of <code>A</code>, then the returned factorization will be a <em>truncated</em> factorization.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigen.21"><h3>eigen!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigen!(A, [B]; permute, scale, sortby)
</code></pre>
<p>Same as <a href="@ref"><code>eigen</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating a copy.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigmax"><h3>eigmax</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigmax(A; permute::Bool=true, scale::Bool=true)
</code></pre>
<p>Return the largest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmax(A)
1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmax(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigmin"><h3>eigmin</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigmin(A; permute::Bool=true, scale::Bool=true)
</code></pre>
<p>Return the smallest eigenvalue of <code>A</code>. The option <code>permute=true</code> permutes the matrix to become closer to upper triangular, and <code>scale=true</code> scales the matrix by its diagonal elements to make rows and columns more equal in norm. Note that if the eigenvalues of <code>A</code> are complex, this method will fail, since complex numbers cannot be sorted.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [0 im; -im 0]
2×2 Array{Complex{Int64},2}:
 0+0im  0+1im
 0-1im  0+0im

julia&gt; eigmin(A)
-1.0

julia&gt; A = [0 im; -1 0]
2×2 Array{Complex{Int64},2}:
  0+0im  0+1im
 -1+0im  0+0im

julia&gt; eigmin(A)
ERROR: DomainError with Complex{Int64}[0+0im 0+1im; -1+0im 0+0im]:
`A` cannot have complex eigenvalues.
Stacktrace:
[...]
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigvals"><h3>eigvals</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigvals(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; values
</code></pre>
<p>Return the eigenvalues of <code>A</code>.</p>
<p>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The <code>permute</code>, <code>scale</code>, and <code>sortby</code> keywords are the same as for <a href="@ref"><code>eigen!</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; diag_matrix = [1 0; 0 4]
2×2 Array{Int64,2}:
 1  0
 0  4

julia&gt; eigvals(diag_matrix)
2-element Array{Float64,1}:
 1.0
 4.0
</code></pre>
<p>For a scalar input, <code>eigvals</code> will return a scalar.</p>
<h1><a href="#example" name="example"></a>Example</h1>
<pre><code class="jldoctest">julia&gt; eigvals(-2)
-2
</code></pre>
<pre><code>eigvals(A, B) -&gt; values
</code></pre>
<p>Computes the generalized eigenvalues of <code>A</code> and <code>B</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvals(A,B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
</code></pre>
<pre><code>eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values
</code></pre>
<p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a <a href="@ref"><code>UnitRange</code></a> <code>irange</code> covering indices of the sorted eigenvalues, e.g. the 2nd to 8th eigenvalues.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, 2:2)
1-element Array{Float64,1}:
 0.9999999999999996

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
</code></pre>
<pre><code>eigvals(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values
</code></pre>
<p>Returns the eigenvalues of <code>A</code>. It is possible to calculate only a subset of the eigenvalues by specifying a pair <code>vl</code> and <code>vu</code> for the lower and upper boundaries of the eigenvalues.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A, -1, 2)
1-element Array{Float64,1}:
 1.0000000000000009

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigvals.21"><h3>eigvals!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigvals!(A; permute::Bool=true, scale::Bool=true, sortby) -&gt; values
</code></pre>
<p>Same as <a href="@ref"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. The <code>permute</code>, <code>scale</code>, and <code>sortby</code> keywords are the same as for <a href="@ref"><code>eigen</code></a>.</p>
<p>!!! note  The input matrix <code>A</code> will not contain its eigenvalues after <code>eigvals!</code> is called on it - <code>A</code> is used as a workspace.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; eigvals!(A)
2-element Array{Float64,1}:
 -0.3722813232690143
  5.372281323269014

julia&gt; A
2×2 Array{Float64,2}:
 -0.372281  -1.0
  0.0        5.37228
</code></pre>
<pre><code>eigvals!(A, B; sortby) -&gt; values
</code></pre>
<p>Same as <a href="@ref"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code> (and <code>B</code>), instead of creating copies.</p>
<p>!!! note  The input matrices <code>A</code> and <code>B</code> will not contain their eigenvalues after <code>eigvals!</code> is called. They are used as workspaces.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; eigvals!(A, B)
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; A
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0  -0.0

julia&gt; B
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
</code></pre>
<pre><code>eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, irange::UnitRange) -&gt; values
</code></pre>
<p>Same as <a href="@ref"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>irange</code> is a range of eigenvalue <em>indices</em> to search for - for instance, the 2nd to 8th eigenvalues.</p>
<pre><code>eigvals!(A::Union{SymTridiagonal, Hermitian, Symmetric}, vl::Real, vu::Real) -&gt; values
</code></pre>
<p>Same as <a href="@ref"><code>eigvals</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. <code>vl</code> is the lower bound of the interval to search for eigenvalues, and <code>vu</code> is the upper bound.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-eigvecs"><h3>eigvecs</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>eigvecs(A::SymTridiagonal[, eigvals]) -&gt; Matrix
</code></pre>
<p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p>
<p>If the optional vector of eigenvalues <code>eigvals</code> is specified, <code>eigvecs</code> returns the specific corresponding eigenvectors.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = SymTridiagonal([1.; 2.; 1.], [2.; 3.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 1.0  2.0   ⋅
 2.0  2.0  3.0
  ⋅   3.0  1.0

julia&gt; eigvals(A)
3-element Array{Float64,1}:
 -2.1400549446402604
  1.0000000000000002
  5.140054944640259

julia&gt; eigvecs(A)
3×3 Array{Float64,2}:
  0.418304  -0.83205      0.364299
 -0.656749  -7.39009e-16  0.754109
  0.627457   0.5547       0.546448

julia&gt; eigvecs(A, [1.])
3×1 Array{Float64,2}:
  0.8320502943378438
  4.263514128092366e-17
 -0.5547001962252291
</code></pre>
<pre><code>eigvecs(A; permute::Bool=true, scale::Bool=true, `sortby`) -&gt; Matrix
</code></pre>
<p>Return a matrix <code>M</code> whose columns are the eigenvectors of <code>A</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.) The <code>permute</code>, <code>scale</code>, and <code>sortby</code> keywords are the same as for <a href="@ref"><code>eigen</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; eigvecs([1.0 0.0 0.0; 0.0 3.0 0.0; 0.0 0.0 18.0])
3×3 Array{Float64,2}:
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0
</code></pre>
<pre><code>eigvecs(A, B) -&gt; Matrix
</code></pre>
<p>Return a matrix <code>M</code> whose columns are the generalized eigenvectors of <code>A</code> and <code>B</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>M[:, k]</code>.)</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; eigvecs(A, B)
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Factorization"><h3>Factorization</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>LinearAlgebra.Factorization
</code></pre>
<p>Abstract type for <a href="https://en.wikipedia.org/wiki/Matrix_decomposition">matrix factorizations</a> a.k.a. matrix decompositions. See [online documentation](@ref man-linalg-factorizations) for a list of available matrix factorizations.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-factorize"><h3>factorize</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>factorize(A)
</code></pre>
<p>Compute a convenient factorization of <code>A</code>, based upon the type of the input matrix. <code>factorize</code> checks <code>A</code> to see if it is symmetric/triangular/etc. if <code>A</code> is passed as a generic matrix. <code>factorize</code> checks every element of <code>A</code> to verify/rule out each property. It will short-circuit as soon as it can rule out symmetry/triangular structure. The return value can be reused for efficient solving of multiple systems. For example: <code>A=factorize(A); x=A\b; y=A\C</code>.</p>
<table>
  <thead>
    <tr>
      <th align="left">Properties of <code>A</code> </th>
      <th align="left">type of factorization </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left">Positive-definite </td>
      <td align="left">Cholesky (see <a href="@ref"><code>cholesky</code></a>) </td>
    </tr>
    <tr>
      <td align="left">Dense Symmetric/Hermitian </td>
      <td align="left">Bunch-Kaufman (see <a href="@ref"><code>bunchkaufman</code></a>) </td>
    </tr>
    <tr>
      <td align="left">Sparse Symmetric/Hermitian </td>
      <td align="left">LDLt (see <a href="@ref"><code>ldlt</code></a>) </td>
    </tr>
    <tr>
      <td align="left">Triangular </td>
      <td align="left">Triangular </td>
    </tr>
    <tr>
      <td align="left">Diagonal </td>
      <td align="left">Diagonal </td>
    </tr>
    <tr>
      <td align="left">Bidiagonal </td>
      <td align="left">Bidiagonal </td>
    </tr>
    <tr>
      <td align="left">Tridiagonal </td>
      <td align="left">LU (see <a href="@ref"><code>lu</code></a>) </td>
    </tr>
    <tr>
      <td align="left">Symmetric real tridiagonal </td>
      <td align="left">LDLt (see <a href="@ref"><code>ldlt</code></a>) </td>
    </tr>
    <tr>
      <td align="left">General square </td>
      <td align="left">LU (see <a href="@ref"><code>lu</code></a>) </td>
    </tr>
    <tr>
      <td align="left">General non-square </td>
      <td align="left">QR (see <a href="@ref"><code>qr</code></a>) </td>
    </tr>
  </tbody>
</table>
<p>If <code>factorize</code> is called on a Hermitian positive-definite matrix, for instance, then <code>factorize</code> will return a Cholesky factorization.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = Array(Bidiagonal(fill(1.0, (5, 5)), :U))
5×5 Array{Float64,2}:
 1.0  1.0  0.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 0.0  0.0  1.0  1.0  0.0
 0.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  1.0

julia&gt; factorize(A) # factorize will check to see that A is already factorized
5×5 Bidiagonal{Float64,Array{Float64,1}}:
 1.0  1.0   ⋅    ⋅    ⋅
  ⋅   1.0  1.0   ⋅    ⋅
  ⋅    ⋅   1.0  1.0   ⋅
  ⋅    ⋅    ⋅   1.0  1.0
  ⋅    ⋅    ⋅    ⋅   1.0
</code></pre>
<p>This returns a <code>5×5 Bidiagonal{Float64}</code>, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for <code>Bidiagonal</code> types.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-GeneralizedEigen"><h3>GeneralizedEigen</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>GeneralizedEigen &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the generalized eigenvalue/spectral decomposition of <code>A</code> and <code>B</code>. This is the return type of <a href="@ref"><code>eigen</code></a>, the corresponding matrix factorization function, when called with two matrix arguments.</p>
<p>If <code>F::GeneralizedEigen</code> is the factorization object, the eigenvalues can be obtained via <code>F.values</code> and the eigenvectors as the columns of the matrix <code>F.vectors</code>. (The <code>k</code>th eigenvector can be obtained from the slice <code>F.vectors[:, k]</code>.)</p>
<p>Iterating the decomposition produces the components <code>F.values</code> and <code>F.vectors</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0; 0 -1]
2×2 Array{Int64,2}:
 1   0
 0  -1

julia&gt; B = [0 1; 1 0]
2×2 Array{Int64,2}:
 0  1
 1  0

julia&gt; F = eigen(A, B)
GeneralizedEigen{Complex{Float64},Complex{Float64},Array{Complex{Float64},2},Array{Complex{Float64},1}}
values:
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im
vectors:
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; F.values
2-element Array{Complex{Float64},1}:
 0.0 - 1.0im
 0.0 + 1.0im

julia&gt; F.vectors
2×2 Array{Complex{Float64},2}:
  0.0+1.0im   0.0-1.0im
 -1.0+0.0im  -1.0-0.0im

julia&gt; vals, vecs = F; # destructuring via iteration

julia&gt; vals == F.values &amp;&amp; vecs == F.vectors
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-GeneralizedSchur"><h3>GeneralizedSchur</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>GeneralizedSchur &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the generalized Schur factorization of two matrices <code>A</code> and <code>B</code>. This is the return type of <a href="@ref"><code>schur(_, _)</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>F::GeneralizedSchur</code> is the factorization object, the (quasi) triangular Schur factors can be obtained via <code>F.S</code> and <code>F.T</code>, the left unitary/orthogonal Schur vectors via <code>F.left</code> or <code>F.Q</code>, and the right unitary/orthogonal Schur vectors can be obtained with <code>F.right</code> or <code>F.Z</code> such that <code>A=F.left*F.S*F.right'</code> and <code>B=F.left*F.T*F.right'</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F.α./F.β</code>.</p>
<p>Iterating the decomposition produces the components <code>F.S</code>, <code>F.T</code>, <code>F.Q</code>, <code>F.Z</code>, <code>F.α</code>, and <code>F.β</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-GeneralizedSVD"><h3>GeneralizedSVD</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>GeneralizedSVD &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the generalized singular value decomposition (SVD) of two matrices <code>A</code> and <code>B</code>, such that <code>A = F.U*F.D1*F.R0*F.Q'</code> and <code>B = F.V*F.D2*F.R0*F.Q'</code>. This is the return type of <a href="@ref"><code>svd(_, _)</code></a>, the corresponding matrix factorization function.</p>
<p>For an M-by-N matrix <code>A</code> and P-by-N matrix <code>B</code>,</p>
<ul>
  <li><code>U</code> is a M-by-M orthogonal matrix,</li>
  <li><code>V</code> is a P-by-P orthogonal matrix,</li>
  <li><code>Q</code> is a N-by-N orthogonal matrix,</li>
  <li><code>D1</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</li>
  <li><code>D2</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</li>
  <li><code>R0</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is nonsingular upper block triangular,</li>
</ul>
<p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code>.</p>
<p>The entries of <code>F.D1</code> and <code>F.D2</code> are related, as explained in the LAPACK documentation for the <a href="http://www.netlib.org/lapack/lug/node36.html">generalized SVD</a> and the <a href="http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html">xGGSVD3</a> routine which is called underneath (in LAPACK 3.6.0 and newer).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; F = svd(A, B)
GeneralizedSVD{Float64,Array{Float64,2}}
U factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
V factor:
2×2 Array{Float64,2}:
 -0.0  -1.0
  1.0   0.0
Q factor:
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
D1 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
D2 factor:
2×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  0.707107
  [2, 2]  =  0.707107
R0 factor:
2×2 Array{Float64,2}:
 1.41421   0.0
 0.0      -1.41421

julia&gt; F.U*F.D1*F.R0*F.Q'
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; F.V*F.D2*F.R0*F.Q'
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-givens"><h3>givens</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>givens(f::T, g::T, i1::Integer, i2::Integer) where {T} -&gt; (G::Givens, r::T)
</code></pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that for any vector <code>x</code> where</p>
<pre><code>x[i1] = f
x[i2] = g
</code></pre>
<p>the result of the multiplication</p>
<pre><code>y = G*x
</code></pre>
<p>has the property that</p>
<pre><code>y[i1] = r
y[i2] = 0
</code></pre>
<p>See also: <a href="@ref"><code>LinearAlgebra.Givens</code></a></p>
<pre><code>givens(A::AbstractArray, i1::Integer, i2::Integer, j::Integer) -&gt; (G::Givens, r)
</code></pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p>
<pre><code>B = G*A
</code></pre>
<p>has the property that</p>
<pre><code>B[i1,j] = r
B[i2,j] = 0
</code></pre>
<p>See also: <a href="@ref"><code>LinearAlgebra.Givens</code></a></p>
<pre><code>givens(x::AbstractVector, i1::Integer, i2::Integer) -&gt; (G::Givens, r)
</code></pre>
<p>Computes the Givens rotation <code>G</code> and scalar <code>r</code> such that the result of the multiplication</p>
<pre><code>B = G*x
</code></pre>
<p>has the property that</p>
<pre><code>B[i1] = r
B[i2] = 0
</code></pre>
<p>See also: <a href="@ref"><code>LinearAlgebra.Givens</code></a></p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Hermitian"><h3>Hermitian</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Hermitian(A, uplo=:U)
</code></pre>
<p>Construct a <code>Hermitian</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0 2+2im 0 3-3im; 0 4 0 5 0; 6-6im 0 7 0 8+8im; 0 9 0 1 0; 2+2im 0 3-3im 0 4];

julia&gt; Hupper = Hermitian(A)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  2+2im  0+0im  3-3im
 0+0im  4+0im  0+0im  5+0im  0+0im
 2-2im  0+0im  7+0im  0+0im  8+8im
 0+0im  5+0im  0+0im  1+0im  0+0im
 3+3im  0+0im  8-8im  0+0im  4+0im

julia&gt; Hlower = Hermitian(A, :L)
5×5 Hermitian{Complex{Int64},Array{Complex{Int64},2}}:
 1+0im  0+0im  6+6im  0+0im  2-2im
 0+0im  4+0im  0+0im  9+0im  0+0im
 6-6im  0+0im  7+0im  0+0im  3+3im
 0+0im  9+0im  0+0im  1+0im  0+0im
 2+2im  0+0im  3-3im  0+0im  4+0im
</code></pre>
<p>Note that <code>Hupper</code> will not be equal to <code>Hlower</code> unless <code>A</code> is itself Hermitian (e.g. if <code>A == adjoint(A)</code>).</p>
<p>All non-real parts of the diagonal will be ignored.</p>
<pre><code class="julia">Hermitian(fill(complex(1,1), 1, 1)) == fill(1, 1, 1)
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Hessenberg"><h3>Hessenberg</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Hessenberg &lt;: Factorization
</code></pre>
<p>A <code>Hessenberg</code> object represents the Hessenberg factorization <code>QHQ'</code> of a square matrix, or a shift <code>Q(H+μI)Q'</code> thereof, which is produced by the <a href="@ref"><code>hessenberg</code></a> function.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-hessenberg"><h3>hessenberg</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>hessenberg(A) -&gt; Hessenberg
</code></pre>
<p>Compute the Hessenberg decomposition of <code>A</code> and return a <code>Hessenberg</code> object. If <code>F</code> is the factorization object, the unitary matrix can be accessed with <code>F.Q</code> (of type <code>LinearAlgebra.HessenbergQ</code>) and the Hessenberg matrix with <code>F.H</code> (of type <a href="@ref"><code>UpperHessenberg</code></a>), either of which may be converted to a regular matrix with <code>Matrix(F.H)</code> or <code>Matrix(F.Q)</code>.</p>
<p>If <code>A</code> is <a href="@ref"><code>Hermitian</code></a> or real-<a href="@ref"><code>Symmetric</code></a>, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and <code>F.H</code> is of type <a href="@ref"><code>SymTridiagonal</code></a>.</p>
<p>Note that the shifted factorization <code>A+μI = Q (H+μI) Q'</code> can be constructed efficiently by <code>F + μ*I</code> using the <a href="@ref"><code>UniformScaling</code></a> object <a href="@ref"><code>I</code></a>, which creates a new <code>Hessenberg</code> object with shared storage and a modified shift. The shift of a given <code>F</code> is obtained by <code>F.μ</code>. This is useful because multiple shifted solves <code>(F + μ*I) \ b</code> (for different <code>μ</code> and/or <code>b</code>) can be performed efficiently once <code>F</code> is created.</p>
<p>Iterating the decomposition produces the factors <code>F.Q, F.H, F.μ</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4. 9. 7.; 4. 4. 1.; 4. 3. 2.]
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; F = hessenberg(A)
Hessenberg{Float64,UpperHessenberg{Float64,Array{Float64,2}},Array{Float64,2},Array{Float64,1},Bool}
Q factor:
3×3 LinearAlgebra.HessenbergQ{Float64,Array{Float64,2},Array{Float64,1},false}:
 1.0   0.0        0.0
 0.0  -0.707107  -0.707107
 0.0  -0.707107   0.707107
H factor:
3×3 UpperHessenberg{Float64,Array{Float64,2}}:
  4.0      -11.3137       -1.41421
 -5.65685    5.0           2.0
   ⋅        -8.88178e-16   1.0

julia&gt; F.Q * F.H * F.Q'
3×3 Array{Float64,2}:
 4.0  9.0  7.0
 4.0  4.0  1.0
 4.0  3.0  2.0

julia&gt; q, h = F; # destructuring via iteration

julia&gt; q == F.Q &amp;&amp; h == F.H
true
</code></pre>
<pre><code>hessenberg(A::Generic.MatrixElem{T}) where {T &lt;: RingElement}
</code></pre>
<p>Return the Hessenberg form of $M$, i.e. an upper Hessenberg matrix which is similar to $M$. The upper Hessenberg form has nonzero entries above and on the diagonal and in the diagonal line immediately below the diagonal.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-hessenberg.21"><h3>hessenberg!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>hessenberg!(A) -&gt; Hessenberg
</code></pre>
<p><code>hessenberg!</code> is the same as <a href="@ref"><code>hessenberg</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-I"><h3>I</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UniformScaling{T&lt;:Number}
</code></pre>
<p>Generically sized uniform scaling operator defined as a scalar times the identity operator, <code>λ*I</code>. See also <a href="@ref"><code>I</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0
</code></pre>
<pre><code>(I::UniformScaling)(n::Integer)
</code></pre>
<p>Construct a <code>Diagonal</code> matrix from a <code>UniformScaling</code>.</p>
<p>!!! compat “Julia 1.2”  This method is available as of Julia 1.2.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; I(3)
3×3 Diagonal{Bool,Array{Bool,1}}:
 1  ⋅  ⋅
 ⋅  1  ⋅
 ⋅  ⋅  1

julia&gt; (0.7*I)(3)
3×3 Diagonal{Float64,Array{Float64,1}}:
 0.7   ⋅    ⋅
  ⋅   0.7   ⋅
  ⋅    ⋅   0.7
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-isdiag"><h3>isdiag</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>isdiag(A) -&gt; Bool
</code></pre>
<p>Test whether a matrix is diagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; isdiag(a)
false

julia&gt; b = [im 0; 0 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  0+0im
 0+0im  0-1im

julia&gt; isdiag(b)
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ishermitian"><h3>ishermitian</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ishermitian(A) -&gt; Bool
</code></pre>
<p>Test whether a matrix is Hermitian.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; ishermitian(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; ishermitian(b)
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-isposdef"><h3>isposdef</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>isposdef(A) -&gt; Bool
</code></pre>
<p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>. See also <a href="@ref"><code>isposdef!</code></a></p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 2 50]
2×2 Array{Int64,2}:
 1   2
 2  50

julia&gt; isposdef(A)
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-isposdef.21"><h3>isposdef!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>isposdef!(A) -&gt; Bool
</code></pre>
<p>Test whether a matrix is positive definite (and Hermitian) by trying to perform a Cholesky factorization of <code>A</code>, overwriting <code>A</code> in the process. See also <a href="@ref"><code>isposdef</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 2.; 2. 50.];

julia&gt; isposdef!(A)
true

julia&gt; A
2×2 Array{Float64,2}:
 1.0  2.0
 2.0  6.78233
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-issuccess"><h3>issuccess</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>issuccess(F::Factorization)
</code></pre>
<p>Test that a factorization of a matrix succeeded.</p>
<pre><code class="jldoctest">julia&gt; F = cholesky([1 0; 0 1]);

julia&gt; LinearAlgebra.issuccess(F)
true

julia&gt; F = lu([1 0; 0 0]; check = false);

julia&gt; LinearAlgebra.issuccess(F)
false
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-issymmetric"><h3>issymmetric</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>issymmetric(A) -&gt; Bool
</code></pre>
<p>Test whether a matrix is symmetric.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; issymmetric(a)
true

julia&gt; b = [1 im; -im 1]
2×2 Array{Complex{Int64},2}:
 1+0im  0+1im
 0-1im  1+0im

julia&gt; issymmetric(b)
false
</code></pre>
<pre><code>issymmetric(a::MatrixElem)
</code></pre>
<p>Return <code>true</code> if the given matrix is symmetric with respect to its main diagonal, otherwise return <code>false</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-istril"><h3>istril</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>istril(A::AbstractMatrix, k::Integer = 0) -&gt; Bool
</code></pre>
<p>Test whether <code>A</code> is lower triangular starting from the <code>k</code>th superdiagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istril(a)
false

julia&gt; istril(a, 1)
true

julia&gt; b = [1 0; -im -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+0im
 0-1im  -1+0im

julia&gt; istril(b)
true

julia&gt; istril(b, -1)
false
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-istriu"><h3>istriu</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>istriu(A::AbstractMatrix, k::Integer = 0) -&gt; Bool
</code></pre>
<p>Test whether <code>A</code> is upper triangular starting from the <code>k</code>th superdiagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1 2; 2 -1]
2×2 Array{Int64,2}:
 1   2
 2  -1

julia&gt; istriu(a)
false

julia&gt; istriu(a, -1)
true

julia&gt; b = [1 im; 0 -1]
2×2 Array{Complex{Int64},2}:
 1+0im   0+1im
 0+0im  -1+0im

julia&gt; istriu(b)
true

julia&gt; istriu(b, 1)
false
</code></pre>
<pre><code>function istriu(A::MatrixElem{T}) where T &lt;: RingElement
</code></pre>
<p>Return <code>true</code> if $A$ is an upper triangular matrix.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-kron"><h3>kron</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>kron(A, B)
</code></pre>
<p>Kronecker tensor product of two vectors or two matrices.</p>
<p>For real vectors <code>v</code> and <code>w</code>, the Kronecker product is related to the outer product by <code>kron(v,w) == vec(w * transpose(v))</code> or <code>w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))</code>. Note how the ordering of <code>v</code> and <code>w</code> differs on the left and right of these expressions (due to column-major storage). For complex vectors, the outer product <code>w * v'</code> also differs by conjugation of <code>v</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; B = [im 1; 1 -im]
2×2 Array{Complex{Int64},2}:
 0+1im  1+0im
 1+0im  0-1im

julia&gt; kron(A, B)
4×4 Array{Complex{Int64},2}:
 0+1im  1+0im  0+2im  2+0im
 1+0im  0-1im  2+0im  0-2im
 0+3im  3+0im  0+4im  4+0im
 3+0im  0-3im  4+0im  0-4im

julia&gt; v = [1, 2]; w = [3, 4, 5];

julia&gt; w*transpose(v)
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10

julia&gt; reshape(kron(v,w), (length(w), length(v)))
3×2 Array{Int64,2}:
 3   6
 4   8
 5  10
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LAPACK"><h3>LAPACK</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Interfaces to LAPACK subroutines.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LAPACKException"><h3>LAPACKException</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>No documentation found.</p>
<h1><a href="#summary" name="summary"></a>Summary</h1>
<pre><code>struct LinearAlgebra.LAPACKException &lt;: Exception
</code></pre>
<h1><a href="#fields" name="fields"></a>Fields</h1>
<pre><code>info :: Int64
</code></pre>
<h1><a href="#supertype-hierarchy" name="supertype-hierarchy"></a>Supertype Hierarchy</h1>
<pre><code>LinearAlgebra.LAPACKException &lt;: Exception &lt;: Any
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ldiv.21"><h3>ldiv!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ldiv!(Y, A, B) -&gt; Y
</code></pre>
<p>Compute <code>A \ B</code> in-place and store the result in <code>Y</code>, returning the result.</p>
<p>The argument <code>A</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="@ref"><code>factorize</code></a> or <a href="@ref"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="@ref"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = zero(X);

julia&gt; ldiv!(Y, qr(A), X);

julia&gt; Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
</code></pre>
<pre><code>ldiv!(A, B)
</code></pre>
<p>Compute <code>A \ B</code> in-place and overwriting <code>B</code> to store the result.</p>
<p>The argument <code>A</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="@ref"><code>factorize</code></a> or <a href="@ref"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="@ref"><code>lu!</code></a>), and performance-critical situations requiring <code>ldiv!</code> usually also require fine-grained control over the factorization of <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2.2 4; 3.1 0.2 3; 4 1 2];

julia&gt; X = [1; 2.5; 3];

julia&gt; Y = copy(X);

julia&gt; ldiv!(qr(A), X);

julia&gt; X
3-element Array{Float64,1}:
  0.7128099173553719
 -0.051652892561983674
  0.10020661157024757

julia&gt; A\Y
3-element Array{Float64,1}:
  0.7128099173553719
 -0.05165289256198333
  0.10020661157024785
</code></pre>
<pre><code>ldiv!(a::Number, B::AbstractArray)
</code></pre>
<p>Divide each entry in an array <code>B</code> by a scalar <code>a</code> overwriting <code>B</code> in-place. Use <a href="@ref"><code>rdiv!</code></a> to divide scalar from right.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; B = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; ldiv!(2.0, B)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
</code></pre>
<p>Solve Hy = rhs for a non-square Hessenberg matrix. Note that <code>H</code> is also modified as is it converted to an upper triangular matrix via Given’s rotations</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LDLt"><h3>LDLt</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>LDLt &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the <code>LDLt</code> factorization of a real <a href="@ref"><code>SymTridiagonal</code></a> matrix <code>S</code> such that <code>S = L*Diagonal(d)*L'</code>, where <code>L</code> is a <a href="@ref"><code>UnitLowerTriangular</code></a> matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldlt(S)</code> is to solve the linear system of equations <code>Sx = b</code> with <code>F\b</code>. This is the return type of <a href="@ref"><code>ldlt</code></a>, the corresponding matrix factorization function.</p>
<p>The individual components of the factorization <code>F::LDLt</code> can be accessed via <code>getproperty</code>:</p>
<table>
  <thead>
    <tr>
      <th align="center">Component </th>
      <th align="left">Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="center"><code>F.L</code> </td>
      <td align="left"><code>L</code> (unit lower triangular) part of <code>LDLt</code> </td>
    </tr>
    <tr>
      <td align="center"><code>F.D</code> </td>
      <td align="left"><code>D</code> (diagonal) part of <code>LDLt</code> </td>
    </tr>
    <tr>
      <td align="center"><code>F.Lt</code> </td>
      <td align="left"><code>Lt</code> (unit upper triangular) part of <code>LDLt</code> </td>
    </tr>
    <tr>
      <td align="center"><code>F.d</code> </td>
      <td align="left">diagonal values of <code>D</code> as a <code>Vector</code> </td>
    </tr>
  </tbody>
</table>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; F = ldlt(S)
LDLt{Float64,SymTridiagonal{Float64,Array{Float64,1}}}
L factor:
3×3 UnitLowerTriangular{Float64,SymTridiagonal{Float64,Array{Float64,1}}}:
 1.0        ⋅         ⋅
 0.333333  1.0        ⋅
 0.0       0.545455  1.0
D factor:
3×3 Diagonal{Float64,Array{Float64,1}}:
 3.0   ⋅        ⋅
  ⋅   3.66667   ⋅
  ⋅    ⋅       3.90909
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ldlt"><h3>ldlt</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ldlt(S::SymTridiagonal) -&gt; LDLt
</code></pre>
<p>Compute an <code>LDLt</code> factorization of the real symmetric tridiagonal matrix <code>S</code> such that <code>S = L*Diagonal(d)*L'</code> where <code>L</code> is a unit lower triangular matrix and <code>d</code> is a vector. The main use of an <code>LDLt</code> factorization <code>F = ldlt(S)</code> is to solve the linear system of equations <code>Sx = b</code> with <code>F\b</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt(S);

julia&gt; b = [6., 7., 8.];

julia&gt; ldltS \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255

julia&gt; S \ b
3-element Array{Float64,1}:
 1.7906976744186047
 0.627906976744186
 1.3488372093023255
</code></pre>
<pre><code>ldlt(A; shift = 0.0, check = true, perm=nothing) -&gt; CHOLMOD.Factor
</code></pre>
<p>Compute the $LDL’$ factorization of a sparse matrix <code>A</code>. <code>A</code> must be a <a href="@ref"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/<a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn’t have the type tag, it must still be symmetric or Hermitian. A fill-reducing permutation is used. <code>F = ldlt(A)</code> is most frequently used to solve systems of equations <code>A*x = b</code> with <code>F\b</code>. The returned factorization object <code>F</code> also supports the methods <a href="@ref"><code>diag</code></a>, <a href="@ref"><code>det</code></a>, <a href="@ref"><code>logdet</code></a>, and <a href="@ref"><code>inv</code></a>. You can extract individual factors from <code>F</code> using <code>F.L</code>. However, since pivoting is on by default, the factorization is internally represented as <code>A == P'*L*D*L'*P</code> with a permutation matrix <code>P</code>; using just <code>L</code> without accounting for <code>P</code> will give incorrect answers. To include the effects of permutation, it is typically preferable to extract “combined” factors like <code>PtL = F.PtL</code> (the equivalent of <code>P'*L</code>) and <code>LtP = F.UP</code> (the equivalent of <code>L'*P</code>). The complete list of supported factors is <code>:L, :PtL, :D, :UP, :U, :LD, :DU, :PtLD, :DUP</code>.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>Setting the optional <code>shift</code> keyword argument computes the factorization of <code>A+shift*I</code> instead of <code>A</code>. If the <code>perm</code> argument is provided, it should be a permutation of <code>1:size(A,1)</code> giving the ordering to use (instead of CHOLMOD’s default AMD ordering).</p>
<p>!!! note  This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p>
<pre><code>Many other functions from CHOLMOD are wrapped but not exported from the `Base.SparseArrays.CHOLMOD` module.
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ldlt.21"><h3>ldlt!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ldlt!(S::SymTridiagonal) -&gt; LDLt
</code></pre>
<p>Same as <a href="@ref"><code>ldlt</code></a>, but saves space by overwriting the input <code>S</code>, instead of creating a copy.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; S = SymTridiagonal([3., 4., 5.], [1., 2.])
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0  1.0   ⋅
 1.0  4.0  2.0
  ⋅   2.0  5.0

julia&gt; ldltS = ldlt!(S);

julia&gt; ldltS === S
false

julia&gt; S
3×3 SymTridiagonal{Float64,Array{Float64,1}}:
 3.0       0.333333   ⋅
 0.333333  3.66667   0.545455
  ⋅        0.545455  3.90909
</code></pre>
<pre><code>ldlt!(F::Factor, A; shift = 0.0, check = true) -&gt; CHOLMOD.Factor
</code></pre>
<p>Compute the $LDL’$ factorization of <code>A</code>, reusing the symbolic factorization <code>F</code>. <code>A</code> must be a <a href="@ref"><code>SparseMatrixCSC</code></a> or a <a href="@ref"><code>Symmetric</code></a>/<a href="@ref"><code>Hermitian</code></a> view of a <code>SparseMatrixCSC</code>. Note that even if <code>A</code> doesn’t have the type tag, it must still be symmetric or Hermitian.</p>
<p>See also <a href="@ref"><code>ldlt</code></a>.</p>
<p>!!! note  This method uses the CHOLMOD library from SuiteSparse, which only supports doubles or complex doubles. Input matrices not of those element types will be converted to <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LinearAlgebra"><h3>LinearAlgebra</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Linear algebra module. Provides array arithmetic, matrix factorizations and other linear algebra related functionality.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lmul.21"><h3>lmul!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lmul!(a::Number, B::AbstractArray)
</code></pre>
<p>Scale an array <code>B</code> by a scalar <code>a</code> overwriting <code>B</code> in-place. Use <a href="@ref"><code>rmul!</code></a> to multiply scalar from right. The scaling operation respects the semantics of the multiplication <a href="@ref"><code>*</code></a> between <code>a</code> and an element of <code>B</code>. In particular, this also applies to multiplication involving non-finite numbers such as <code>NaN</code> and <code>±Inf</code>.</p>
<p>!!! compat “Julia 1.1”  Prior to Julia 1.1, <code>NaN</code> and <code>±Inf</code> entries in <code>B</code> were treated inconsistently.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; B = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; lmul!(2, B)
2×2 Array{Int64,2}:
 2  4
 6  8

julia&gt; lmul!(0.0, [Inf])
1-element Array{Float64,1}:
 NaN
</code></pre>
<pre><code>lmul!(A, B)
</code></pre>
<p>Calculate the matrix-matrix product $AB$, overwriting <code>B</code>, and return the result. Here, <code>A</code> must be of special matrix type, like, e.g., <a href="@ref"><code>Diagonal</code></a>, <a href="@ref"><code>UpperTriangular</code></a> or <a href="@ref"><code>LowerTriangular</code></a>, or of some orthogonal type, see <a href="@ref"><code>QR</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; B = [0 1; 1 0];

julia&gt; A = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.lmul!(A, B);

julia&gt; B
2×2 Array{Int64,2}:
 2  1
 3  0

julia&gt; B = [1.0 2.0; 3.0 4.0];

julia&gt; F = qr([0 1; -1 0]);

julia&gt; lmul!(F.Q, B)
2×2 Array{Float64,2}:
 3.0  4.0
 1.0  2.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-logabsdet"><h3>logabsdet</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>logabsdet(M)
</code></pre>
<p>Log of absolute value of matrix determinant. Equivalent to <code>(log(abs(det(M))), sign(det(M)))</code>, but may provide increased accuracy and/or speed.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [-1. 0.; 0. 1.]
2×2 Array{Float64,2}:
 -1.0  0.0
  0.0  1.0

julia&gt; det(A)
-1.0

julia&gt; logabsdet(A)
(0.0, -1.0)

julia&gt; B = [2. 0.; 0. 1.]
2×2 Array{Float64,2}:
 2.0  0.0
 0.0  1.0

julia&gt; det(B)
2.0

julia&gt; logabsdet(B)
(0.6931471805599453, 1.0)
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-logdet"><h3>logdet</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>logdet(M)
</code></pre>
<p>Log of matrix determinant. Equivalent to <code>log(det(M))</code>, but may provide increased accuracy and/or speed.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1 0; 2 2]
2×2 Array{Int64,2}:
 1  0
 2  2

julia&gt; logdet(M)
0.6931471805599453

julia&gt; logdet(Matrix(I, 3, 3))
0.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LowerTriangular"><h3>LowerTriangular</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>LowerTriangular(A::AbstractMatrix)
</code></pre>
<p>Construct a <code>LowerTriangular</code> view of the matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; LowerTriangular(A)
3×3 LowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  5.0   ⋅
 7.0  8.0  9.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lowrankdowndate"><h3>lowrankdowndate</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lowrankdowndate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky
</code></pre>
<p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U - v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lowrankdowndate.21"><h3>lowrankdowndate!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lowrankdowndate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky
</code></pre>
<p>Downdate a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U - v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lowrankupdate"><h3>lowrankupdate</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lowrankupdate(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky
</code></pre>
<p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U + v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lowrankupdate.21"><h3>lowrankupdate!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lowrankupdate!(C::Cholesky, v::StridedVector) -&gt; CC::Cholesky
</code></pre>
<p>Update a Cholesky factorization <code>C</code> with the vector <code>v</code>. If <code>A = C.U'C.U</code> then <code>CC = cholesky(C.U'C.U + v*v')</code> but the computation of <code>CC</code> only uses <code>O(n^2)</code> operations. The input factorization <code>C</code> is updated in place such that on exit <code>C == CC</code>. The vector <code>v</code> is destroyed during the computation.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LQ"><h3>LQ</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>LQ &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the <code>LQ</code> factorization of a matrix <code>A</code>. The <code>LQ</code> decomposition is the <a href="@ref"><code>QR</code></a> decomposition of <code>transpose(A)</code>. This is the return type of <a href="@ref"><code>lq</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>S::LQ</code> is the factorization object, the lower triangular component can be obtained via <code>S.L</code>, and the orthogonal/unitary component via <code>S.Q</code>, such that <code>A ≈ S.L*S.Q</code>.</p>
<p>Iterating the decomposition produces the components <code>S.L</code> and <code>S.Q</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia&gt; S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # destructuring via iteration

julia&gt; l == S.L &amp;&amp;  q == S.Q
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lq"><h3>lq</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lq(A) -&gt; S::LQ
</code></pre>
<p>Compute the LQ decomposition of <code>A</code>. The decomposition’s lower triangular component can be obtained from the <a href="@ref"><code>LQ</code></a> object <code>S</code> via <code>S.L</code>, and the orthogonal/unitary component via <code>S.Q</code>, such that <code>A ≈ S.L*S.Q</code>.</p>
<p>Iterating the decomposition produces the components <code>S.L</code> and <code>S.Q</code>.</p>
<p>The LQ decomposition is the QR decomposition of <code>transpose(A)</code>, and it is useful in order to compute the minimum-norm solution <code>lq(A) \ b</code> to an underdetermined system of equations (<code>A</code> has more columns than rows, but has full row rank).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; S = lq(A)
LQ{Float64,Array{Float64,2}} with factors L and Q:
[-8.60233 0.0; 4.41741 -0.697486]
[-0.581238 -0.813733; -0.813733 0.581238]

julia&gt; S.L * S.Q
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; l, q = S; # destructuring via iteration

julia&gt; l == S.L &amp;&amp;  q == S.Q
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lq.21"><h3>lq!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lq!(A) -&gt; LQ
</code></pre>
<p>Compute the <a href="@ref"><code>LQ</code></a> factorization of <code>A</code>, using the input matrix as a workspace. See also <a href="@ref"><code>lq</code></a>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-LU"><h3>LU</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>LU &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the <code>LU</code> factorization of a square matrix <code>A</code>. This is the return type of <a href="@ref"><code>lu</code></a>, the corresponding matrix factorization function.</p>
<p>The individual components of the factorization <code>F::LU</code> can be accessed via <a href="@ref"><code>getproperty</code></a>:</p>
<table>
  <thead>
    <tr>
      <th align="left">Component </th>
      <th align="left">Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>F.L</code> </td>
      <td align="left"><code>L</code> (unit lower triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.U</code> </td>
      <td align="left"><code>U</code> (upper triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.p</code> </td>
      <td align="left">(right) permutation <code>Vector</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.P</code> </td>
      <td align="left">(right) permutation <code>Matrix</code> </td>
    </tr>
  </tbody>
</table>
<p>Iterating the factorization produces the components <code>F.L</code>, <code>F.U</code>, and <code>F.p</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # destructuring via iteration

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lu"><h3>lu</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lu(A, pivot=Val(true); check = true) -&gt; F::LU
</code></pre>
<p>Compute the LU factorization of <code>A</code>.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>In most cases, if <code>A</code> is a subtype <code>S</code> of <code>AbstractMatrix{T}</code> with an element type <code>T</code> supporting <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, the return type is <code>LU{T,S{T}}</code>. If pivoting is chosen (default) the element type should also support <a href="@ref"><code>abs</code></a> and <a href="@ref"><code>&lt;</code></a>.</p>
<p>The individual components of the factorization <code>F</code> can be accessed via <a href="@ref"><code>getproperty</code></a>:</p>
<table>
  <thead>
    <tr>
      <th align="left">Component </th>
      <th align="left">Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>F.L</code> </td>
      <td align="left"><code>L</code> (lower triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.U</code> </td>
      <td align="left"><code>U</code> (upper triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.p</code> </td>
      <td align="left">(right) permutation <code>Vector</code> </td>
    </tr>
    <tr>
      <td align="left"><code>F.P</code> </td>
      <td align="left">(right) permutation <code>Matrix</code> </td>
    </tr>
  </tbody>
</table>
<p>Iterating the factorization produces the components <code>F.L</code>, <code>F.U</code>, and <code>F.p</code>.</p>
<p>The relationship between <code>F</code> and <code>A</code> is</p>
<p><code>F.L*F.U == A[F.p, :]</code></p>
<p><code>F</code> further supports the following functions:</p>
<table>
  <thead>
    <tr>
      <th align="left">Supported function </th>
      <th align="left"><code>LU</code> </th>
      <th align="left"><code>LU{T,Tridiagonal{T}}</code> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><a href="@ref"><code>/</code></a> </td>
      <td align="left">✓ </td>
      <td align="left"> </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>\</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>inv</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>det</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>logdet</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>logabsdet</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
    <tr>
      <td align="left"><a href="@ref"><code>size</code></a> </td>
      <td align="left">✓ </td>
      <td align="left">✓ </td>
    </tr>
  </tbody>
</table>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; F = lu(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; F.L * F.U == A[F.p, :]
true

julia&gt; l, u, p = lu(A); # destructuring via iteration

julia&gt; l == F.L &amp;&amp; u == F.U &amp;&amp; p == F.p
true
</code></pre>
<pre><code>lu(A::SparseMatrixCSC; check = true) -&gt; F::UmfpackLU
</code></pre>
<p>Compute the LU factorization of a sparse matrix <code>A</code>.</p>
<p>For sparse <code>A</code> with real or complex element type, the return type of <code>F</code> is <code>UmfpackLU{Tv, Ti}</code>, with <code>Tv</code> = <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> respectively and <code>Ti</code> is an integer type (<a href="@ref"><code>Int32</code></a> or <a href="@ref"><code>Int64</code></a>).</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>The individual components of the factorization <code>F</code> can be accessed by indexing:</p>
<table>
  <thead>
    <tr>
      <th align="left">Component </th>
      <th align="left">Description </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td align="left"><code>L</code> </td>
      <td align="left"><code>L</code> (lower triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>U</code> </td>
      <td align="left"><code>U</code> (upper triangular) part of <code>LU</code> </td>
    </tr>
    <tr>
      <td align="left"><code>p</code> </td>
      <td align="left">right permutation <code>Vector</code> </td>
    </tr>
    <tr>
      <td align="left"><code>q</code> </td>
      <td align="left">left permutation <code>Vector</code> </td>
    </tr>
    <tr>
      <td align="left"><code>Rs</code> </td>
      <td align="left"><code>Vector</code> of scaling factors </td>
    </tr>
    <tr>
      <td align="left"><code>:</code> </td>
      <td align="left"><code>(L,U,p,q,Rs)</code> components </td>
    </tr>
  </tbody>
</table>
<p>The relation between <code>F</code> and <code>A</code> is</p>
<p><code>F.L*F.U == (F.Rs .* A)[F.p, F.q]</code></p>
<p><code>F</code> further supports the following functions:</p>
<ul>
  <li><a href="@ref"><code>\</code></a></li>
  <li><a href="@ref"><code>cond</code></a></li>
  <li><a href="@ref"><code>det</code></a></li>
</ul>
<p>!!! note  <code>lu(A::SparseMatrixCSC)</code> uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> elements, <code>lu</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p>
<pre><code>lu(A::Generic.MatrixElem{T}, P = SymmetricGroup(nrows(A))) where {T &lt;: FieldElement}
</code></pre>
<p>Return a tuple $r, p, L, U$ consisting of the rank of $A$, a permutation $p$ of $A$ belonging to $P$, a lower triangular matrix $L$ and an upper triangular matrix $U$ such that $p(A) = LU$, where $p(A)$ stands for the matrix whose rows are the given permutation $p$ of the rows of $A$.</p>
<pre><code>lu(A, CompletePivoting) → CompletelyPivotedLU(B, p, q)
</code></pre>
<p>Computes the LU factorization of A using complete pivoting.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lu.21"><h3>lu!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lu!(A, pivot=Val(true); check = true) -&gt; LU
</code></pre>
<p><code>lu!</code> is the same as <a href="@ref"><code>lu</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="@ref"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [4. 3.; 6. 3.]
2×2 Array{Float64,2}:
 4.0  3.0
 6.0  3.0

julia&gt; F = lu!(A)
LU{Float64,Array{Float64,2}}
L factor:
2×2 Array{Float64,2}:
 1.0       0.0
 0.666667  1.0
U factor:
2×2 Array{Float64,2}:
 6.0  3.0
 0.0  1.0

julia&gt; iA = [4 3; 6 3]
2×2 Array{Int64,2}:
 4  3
 6  3

julia&gt; lu!(iA)
ERROR: InexactError: Int64(0.6666666666666666)
Stacktrace:
[...]
</code></pre>
<pre><code>lu!(F::UmfpackLU, A::SparseMatrixCSC; check=true) -&gt; F::UmfpackLU
</code></pre>
<p>Compute the LU factorization of a sparse matrix <code>A</code>, reusing the symbolic factorization of an already existing LU factorization stored in <code>F</code>. The sparse matrix <code>A</code> must have an identical nonzero pattern as the matrix used to create the LU factorization <code>F</code>, otherwise an error is thrown.</p>
<p>When <code>check = true</code>, an error is thrown if the decomposition fails. When <code>check = false</code>, responsibility for checking the decomposition’s validity (via <a href="@ref"><code>issuccess</code></a>) lies with the user.</p>
<p>!!! note  <code>lu!(F::UmfpackLU, A::SparseMatrixCSC)</code> uses the UMFPACK library that is part of SuiteSparse. As this library only supports sparse matrices with <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> elements, <code>lu!</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p>
<p>!!! compat “Julia 1.5”  <code>lu!</code> for <code>UmfpackLU</code> requires at least Julia 1.5.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = sparse(Float64[1.0 2.0; 0.0 3.0]);

julia&gt; F = lu(A);

julia&gt; B = sparse(Float64[1.0 1.0; 0.0 1.0]);

julia&gt; lu!(F, B);

julia&gt; F \ ones(2)
2-element Array{Float64,1}:
 0.0
 1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-lyap"><h3>lyap</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>lyap(A, C)
</code></pre>
<p>Computes the solution <code>X</code> to the continuous Lyapunov equation <code>AX + XA' + C = 0</code>, where no eigenvalue of <code>A</code> has a zero real part and no two eigenvalues are negative complex conjugates of each other.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; X = lyap(A, B)
2×2 Array{Float64,2}:
  0.5  -0.5
 -0.5   0.25

julia&gt; A*X + X*A' + B
2×2 Array{Float64,2}:
 0.0          6.66134e-16
 6.66134e-16  8.88178e-16
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-module"><h3>module</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-mul.21"><h3>mul!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>mul!(Y, A, B) -&gt; Y
</code></pre>
<p>Calculates the matrix-matrix or matrix-vector product $AB$ and stores the result in <code>Y</code>, overwriting the existing value of <code>Y</code>. Note that <code>Y</code> must not be aliased with either <code>A</code> or <code>B</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; Y = similar(B); mul!(Y, A, B);

julia&gt; Y
2×2 Array{Float64,2}:
 3.0  3.0
 7.0  7.0
</code></pre>
<h1><a href="#implementation" name="implementation"></a>Implementation</h1>
<p>For custom matrix and vector types, it is recommended to implement 5-argument <code>mul!</code> rather than implementing 3-argument <code>mul!</code> directly if possible.</p>
<pre><code>mul!(C, A, B, α, β) -&gt; C
</code></pre>
<p>Combined inplace matrix-matrix or matrix-vector multiply-add $A B α + C β$. The result is stored in <code>C</code> by overwriting it. Note that <code>C</code> must not be aliased with either <code>A</code> or <code>B</code>.</p>
<p>!!! compat “Julia 1.3”  Five-argument <code>mul!</code> requires at least Julia 1.3.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A=[1.0 2.0; 3.0 4.0]; B=[1.0 1.0; 1.0 1.0]; C=[1.0 2.0; 3.0 4.0];

julia&gt; mul!(C, A, B, 100.0, 10.0) === C
true

julia&gt; C
2×2 Array{Float64,2}:
 310.0  320.0
 730.0  740.0
</code></pre>
<p>Do mul! with the off-diagonal elements of a matrix.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-norm"><h3>norm</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>norm(A, p::Real=2)
</code></pre>
<p>For any iterable container <code>A</code> (including arrays of any dimension) of numbers (or any element type for which <code>norm</code> is defined), compute the <code>p</code>-norm (defaulting to <code>p=2</code>) as if <code>A</code> were a vector of the corresponding length.</p>
<p>The <code>p</code>-norm is defined as</p>
<p>$$ |A|_p = \left( \sum_{i=1}^n | a_i | ^p \right)^{1/p} $$</p>
<p>with $a_i$ the entries of $A$, $| a_i |$ the <a href="@ref"><code>norm</code></a> of $a_i$, and $n$ the length of $A$. Since the <code>p</code>-norm is computed using the <a href="@ref"><code>norm</code></a>s of the entries of <code>A</code>, the <code>p</code>-norm of a vector of vectors is not compatible with the interpretation of it as a block vector in general if <code>p != 2</code>.</p>
<p><code>p</code> can assume any numeric value (even though not all values produce a mathematically valid vector norm). In particular, <code>norm(A, Inf)</code> returns the largest value in <code>abs.(A)</code>, whereas <code>norm(A, -Inf)</code> returns the smallest. If <code>A</code> is a matrix and <code>p=2</code>, then this is equivalent to the Frobenius norm.</p>
<p>The second argument <code>p</code> is not necessarily a part of the interface for <code>norm</code>, i.e. a custom type may only implement <code>norm(A)</code> without second argument.</p>
<p>Use <a href="@ref"><code>opnorm</code></a> to compute the operator norm of a matrix.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; v = [3, -2, 6]
3-element Array{Int64,1}:
  3
 -2
  6

julia&gt; norm(v)
7.0

julia&gt; norm(v, 1)
11.0

julia&gt; norm(v, Inf)
6.0

julia&gt; norm([1 2 3; 4 5 6; 7 8 9])
16.881943016134134

julia&gt; norm([1 2 3 4 5 6 7 8 9])
16.881943016134134

julia&gt; norm(1:9)
16.881943016134134

julia&gt; norm(hcat(v,v), 1) == norm(vcat(v,v), 1) != norm([v,v], 1)
true

julia&gt; norm(hcat(v,v), 2) == norm(vcat(v,v), 2) == norm([v,v], 2)
true

julia&gt; norm(hcat(v,v), Inf) == norm(vcat(v,v), Inf) != norm([v,v], Inf)
true
</code></pre>
<pre><code>norm(x::Number, p::Real=2)
</code></pre>
<p>For numbers, return $\left( |x|^p \right)^{1/p}$.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; norm(2, 1)
2.0

julia&gt; norm(-2, 1)
2.0

julia&gt; norm(2, 2)
2.0

julia&gt; norm(-2, 2)
2.0

julia&gt; norm(2, Inf)
2.0

julia&gt; norm(-2, Inf)
2.0
</code></pre>
<pre><code>norm(h::Histogram)
</code></pre>
<p>Calculate the norm of histogram <code>h</code> as the absolute value of its integral.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-normalize"><h3>normalize</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>normalize(a::AbstractArray, p::Real=2)
</code></pre>
<p>Normalize the array <code>a</code> so that its <code>p</code>-norm equals unity, i.e. <code>norm(a, p) == 1</code>. See also <a href="@ref"><code>normalize!</code></a> and <a href="@ref"><code>norm</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1,2,4];

julia&gt; b = normalize(a)
3-element Array{Float64,1}:
 0.2182178902359924
 0.4364357804719848
 0.8728715609439696

julia&gt; norm(b)
1.0

julia&gt; c = normalize(a, 1)
3-element Array{Float64,1}:
 0.14285714285714285
 0.2857142857142857
 0.5714285714285714

julia&gt; norm(c, 1)
1.0

julia&gt; a = [1 2 4 ; 1 2 4]
2×3 Array{Int64,2}:
 1  2  4
 1  2  4

julia&gt; norm(a)
6.48074069840786

julia&gt; normalize(a)
2×3 Array{Float64,2}:
 0.154303  0.308607  0.617213
 0.154303  0.308607  0.617213

</code></pre>
<pre><code>normalize(h::Histogram{T,N}; mode::Symbol=:pdf) where {T,N}
</code></pre>
<p>Normalize the histogram <code>h</code>.</p>
<p>Valid values for <code>mode</code> are:</p>
<ul>
  <li><code>:pdf</code>: Normalize by sum of weights and bin sizes. Resulting histogram has norm 1 and represents a PDF.</li>
  <li><code>:density</code>: Normalize by bin sizes only. Resulting histogram represents count density of input and does not have norm 1. Will not modify the histogram if it already represents a density (<code>h.isdensity == 1</code>).</li>
  <li><code>:probability</code>: Normalize by sum of weights only. Resulting histogram represents the fraction of probability mass for each bin and does not have norm 1.</li>
  <li><code>:none</code>: Leaves histogram unchanged. Useful to simplify code that has to conditionally apply different modes of normalization.</li>
</ul>
<p>Successive application of both <code>:probability</code> and <code>:density</code> normalization (in any order) is equivalent to <code>:pdf</code> normalization.</p>
<pre><code>normalize(h::Histogram{T,N}, aux_weights::Array{T,N}...; mode::Symbol=:pdf) where {T,N}
</code></pre>
<p>Normalize the histogram <code>h</code> and rescales one or more auxiliary weight arrays at the same time (<code>aux_weights</code> may, e.g., contain estimated statistical uncertainties). The values of the auxiliary arrays are scaled by the same factor as the corresponding histogram weight values. Returns a tuple of the normalized histogram and scaled auxiliary weights.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-normalize.21"><h3>normalize!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>normalize!(a::AbstractArray, p::Real=2)
</code></pre>
<p>Normalize the array <code>a</code> in-place so that its <code>p</code>-norm equals unity, i.e. <code>norm(a, p) == 1</code>. See also <a href="@ref"><code>normalize</code></a> and <a href="@ref"><code>norm</code></a>.</p>
<pre><code>normalize!(h::Histogram{T,N}, aux_weights::Array{T,N}...; mode::Symbol=:pdf) where {T&lt;:AbstractFloat,N}
</code></pre>
<p>Normalize the histogram <code>h</code> and optionally scale one or more auxiliary weight arrays appropriately. See description of <code>normalize</code> for details. Returns <code>h</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-nullspace"><h3>nullspace</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>nullspace(M; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
nullspace(M, rtol::Real) = nullspace(M; rtol=rtol) # to be deprecated in Julia 2.0
</code></pre>
<p>Computes a basis for the nullspace of <code>M</code> by including the singular vectors of <code>M</code> whose singular values have magnitudes greater than <code>max(atol, rtol*σ₁)</code>, where <code>σ₁</code> is <code>M</code>’s largest singular value.</p>
<p>By default, the relative tolerance <code>rtol</code> is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of <code>M</code>, and <code>ϵ</code> is the <a href="@ref"><code>eps</code></a> of the element type of <code>M</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1 0 0; 0 1 0; 0 0 0]
3×3 Array{Int64,2}:
 1  0  0
 0  1  0
 0  0  0

julia&gt; nullspace(M)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0

julia&gt; nullspace(M, rtol=3)
3×3 Array{Float64,2}:
 0.0  1.0  0.0
 1.0  0.0  0.0
 0.0  0.0  1.0

julia&gt; nullspace(M, atol=0.95)
3×1 Array{Float64,2}:
 0.0
 0.0
 1.0
</code></pre>
<pre><code>nullspace(M::AbstractAlgebra.MatElem{T}) where {T &lt;: RingElement}
</code></pre>
<p>Return a tuple $(\nu, N)$ consisting of the nullity $\nu$ of $M$ and a basis $N$ (consisting of column vectors) for the right nullspace of $M$, i.e. such that $MN$ is the zero matrix. If $M$ is an $m\times n$ matrix $N$ will be an $n\times \nu$ matrix. Note that the nullspace is taken to be the vector space kernel over the fraction field of the base ring if the latter is not a field. In AbstractAlgebra we use the name “kernel” for a function to compute an integral kernel.</p>
<pre><code>nullspace(M::AbstractAlgebra.MatElem{T}) where {T &lt;: FieldElement}
</code></pre>
<p>Return a tuple $(\nu, N)$ consisting of the nullity $\nu$ of $M$ and a basis $N$ (consisting of column vectors) for the right nullspace of $M$, i.e. such that $MN$ is the zero matrix. If $M$ is an $m\times n$ matrix $N$ will be an $n\times \nu$ matrix.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-opnorm"><h3>opnorm</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>opnorm(A::AbstractMatrix, p::Real=2)
</code></pre>
<p>Compute the operator norm (or matrix norm) induced by the vector <code>p</code>-norm, where valid values of <code>p</code> are <code>1</code>, <code>2</code>, or <code>Inf</code>. (Note that for sparse matrices, <code>p=2</code> is currently not implemented.) Use <a href="@ref"><code>norm</code></a> to compute the Frobenius norm.</p>
<p>When <code>p=1</code>, the operator norm is the maximum absolute column sum of <code>A</code>:</p>
<p>$$ |A|_1 = \max_{1 ≤ j ≤ n} \sum_{i=1}^m | a_{ij} | $$</p>
<p>with $a_{ij}$ the entries of $A$, and $m$ and $n$ its dimensions.</p>
<p>When <code>p=2</code>, the operator norm is the spectral norm, equal to the largest singular value of <code>A</code>.</p>
<p>When <code>p=Inf</code>, the operator norm is the maximum absolute row sum of <code>A</code>:</p>
<p>$$ |A|_\infty = \max_{1 ≤ i ≤ m} \sum <em>{j=1}^n | a</em>{ij} | $$</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 -2 -3; 2 3 -1]
2×3 Array{Int64,2}:
 1  -2  -3
 2   3  -1

julia&gt; opnorm(A, Inf)
6.0

julia&gt; opnorm(A, 1)
5.0
</code></pre>
<pre><code>opnorm(x::Number, p::Real=2)
</code></pre>
<p>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to <a href="@ref"><code>norm</code></a>.</p>
<pre><code>opnorm(A::Adjoint{&lt;:Any,&lt;:AbstracVector}, q::Real=2)
opnorm(A::Transpose{&lt;:Any,&lt;:AbstracVector}, q::Real=2)
</code></pre>
<p>For Adjoint/Transpose-wrapped vectors, return the operator $q$-norm of <code>A</code>, which is equivalent to the <code>p</code>-norm with value <code>p = q/(q-1)</code>. They coincide at <code>p = q = 2</code>. Use <a href="@ref"><code>norm</code></a> to compute the <code>p</code> norm of <code>A</code> as a vector.</p>
<p>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator <code>p</code>-norm of a <code>1 × n</code> matrix.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; v = [1; im];

julia&gt; vc = v';

julia&gt; opnorm(vc, 1)
1.0

julia&gt; norm(vc, 1)
2.0

julia&gt; norm(v, 1)
2.0

julia&gt; opnorm(vc, 2)
1.4142135623730951

julia&gt; norm(vc, 2)
1.4142135623730951

julia&gt; norm(v, 2)
1.4142135623730951

julia&gt; opnorm(vc, Inf)
2.0

julia&gt; norm(vc, Inf)
1.0

julia&gt; norm(v, Inf)
1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ordschur"><h3>ordschur</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ordschur(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur
</code></pre>
<p>Reorders the Schur factorization <code>F</code> of a matrix <code>A = Z*T*Z'</code> according to the logical array <code>select</code> returning the reordered factorization <code>F</code> object. The selected eigenvalues appear in the leading diagonal of <code>F.Schur</code> and the corresponding leading columns of <code>F.vectors</code> form an orthogonal/unitary basis of the corresponding right invariant subspace. In the real case, a complex conjugate pair of eigenvalues must be either both included or both excluded via <code>select</code>.</p>
<pre><code>ordschur(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur
</code></pre>
<p>Reorders the Generalized Schur factorization <code>F</code> of a matrix pair <code>(A, B) = (Q*S*Z', Q*T*Z')</code> according to the logical array <code>select</code> and returns a GeneralizedSchur object <code>F</code>. The selected eigenvalues appear in the leading diagonal of both <code>F.S</code> and <code>F.T</code>, and the left and right orthogonal/unitary Schur vectors are also reordered such that <code>(A, B) = F.Q*(F.S, F.T)*F.Z'</code> still holds and the generalized eigenvalues of <code>A</code> and <code>B</code> can still be obtained with <code>F.α./F.β</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ordschur.21"><h3>ordschur!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ordschur!(F::Schur, select::Union{Vector{Bool},BitVector}) -&gt; F::Schur
</code></pre>
<p>Same as <a href="@ref"><code>ordschur</code></a> but overwrites the factorization <code>F</code>.</p>
<pre><code>ordschur!(F::GeneralizedSchur, select::Union{Vector{Bool},BitVector}) -&gt; F::GeneralizedSchur
</code></pre>
<p>Same as <code>ordschur</code> but overwrites the factorization <code>F</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-pinv"><h3>pinv</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>pinv(M; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
pinv(M, rtol::Real) = pinv(M; rtol=rtol) # to be deprecated in Julia 2.0
</code></pre>
<p>Computes the Moore-Penrose pseudoinverse.</p>
<p>For matrices <code>M</code> with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than <code>max(atol, rtol*σ₁)</code> where <code>σ₁</code> is the largest singular value of <code>M</code>.</p>
<p>The optimal choice of absolute (<code>atol</code>) and relative tolerance (<code>rtol</code>) varies both with the value of <code>M</code> and the intended application of the pseudoinverse. The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of <code>M</code>, and <code>ϵ</code> is the <a href="@ref"><code>eps</code></a> of the element type of <code>M</code>.</p>
<p>For inverting dense ill-conditioned matrices in a least-squares sense, <code>rtol = sqrt(eps(real(float(one(eltype(M))))))</code> is recommended.</p>
<p>For more information, see [^issue8859], [^B96], [^S84], [^KY88].</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1.5 1.3; 1.2 1.9]
2×2 Array{Float64,2}:
 1.5  1.3
 1.2  1.9

julia&gt; N = pinv(M)
2×2 Array{Float64,2}:
  1.47287   -1.00775
 -0.930233   1.16279

julia&gt; M * N
2×2 Array{Float64,2}:
 1.0          -2.22045e-16
 4.44089e-16   1.0
</code></pre>
<p>[^issue8859]: Issue 8859, “Fix least squares”, <a href="https://github.com/JuliaLang/julia/pull/8859">https://github.com/JuliaLang/julia/pull/8859</a></p>
<p>[^B96]: Åke Björck, “Numerical Methods for Least Squares Problems”, SIAM Press, Philadelphia, 1996, “Other Titles in Applied Mathematics”, Vol. 51. <a href="http://epubs.siam.org/doi/book/10.1137/1.9781611971484">doi:10.1137/1.9781611971484</a></p>
<p>[^S84]: G. W. Stewart, “Rank Degeneracy”, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. <a href="http://epubs.siam.org/doi/abs/10.1137/0905030">doi:10.1137/0905030</a></p>
<p>[^KY88]: Konstantinos Konstantinides and Kung Yao, “Statistical analysis of effective singular values in matrix rank determination”, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. <a href="https://doi.org/10.1109/29.1585">doi:10.1109/29.1585</a></p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-PosDefException"><h3>PosDefException</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>PosDefException
</code></pre>
<p>Exception thrown when the input matrix was not <a href="https://en.wikipedia.org/wiki/Definiteness_of_a_matrix">positive definite</a>. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The <code>info</code> field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-QR"><h3>QR</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>QR &lt;: Factorization
</code></pre>
<p>A QR matrix factorization stored in a packed format, typically obtained from <a href="@ref"><code>qr</code></a>. If $A$ is an <code>m</code>×<code>n</code> matrix, then</p>
<p>$$ A = Q R $$</p>
<p>where $Q$ is an orthogonal/unitary matrix and $R$ is upper triangular. The matrix $Q$ is stored as a sequence of Householder reflectors $v_i$ and coefficients $\tau_i$ where:</p>
<p>$$ Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T). $$</p>
<p>Iterating the decomposition produces the components <code>Q</code> and <code>R</code>.</p>
<p>The object has two fields:</p>
<ul>
  <li><code>factors</code> is an <code>m</code>×<code>n</code> matrix.
    <ul>
      <li>The upper triangular part contains the elements of $R$, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</li>
      <li>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</li>
    </ul>
  </li>
  <li><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients $au_i$.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-qr"><h3>qr</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>qr(A, pivot=Val(false); blocksize) -&gt; F
</code></pre>
<p>Compute the QR factorization of the matrix <code>A</code>: an orthogonal (or unitary if <code>A</code> is complex-valued) matrix <code>Q</code>, and an upper triangular matrix <code>R</code> such that</p>
<p>$$ A = Q R $$</p>
<p>The returned object <code>F</code> stores the factorization in a packed format:</p>
<ul>
  <li>if <code>pivot == Val(true)</code> then <code>F</code> is a <a href="@ref"><code>QRPivoted</code></a> object,</li>
  <li>otherwise if the element type of <code>A</code> is a BLAS type (<a href="@ref"><code>Float32</code></a>, <a href="@ref"><code>Float64</code></a>, <code>ComplexF32</code> or <code>ComplexF64</code>), then <code>F</code> is a <a href="@ref"><code>QRCompactWY</code></a> object,</li>
  <li>otherwise <code>F</code> is a <a href="@ref"><code>QR</code></a> object.</li>
</ul>
<p>The individual components of the decomposition <code>F</code> can be retrieved via property accessors:</p>
<ul>
  <li><code>F.Q</code>: the orthogonal/unitary matrix <code>Q</code></li>
  <li><code>F.R</code>: the upper triangular matrix <code>R</code></li>
  <li><code>F.p</code>: the permutation vector of the pivot (<a href="@ref"><code>QRPivoted</code></a> only)</li>
  <li><code>F.P</code>: the permutation matrix of the pivot (<a href="@ref"><code>QRPivoted</code></a> only)</li>
</ul>
<p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and if extant <code>p</code>.</p>
<p>The following functions are available for the <code>QR</code> objects: <a href="@ref"><code>inv</code></a>, <a href="@ref"><code>size</code></a>, and <a href="@ref"><code>\</code></a>. When <code>A</code> is rectangular, <code>\</code> will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When <code>A</code> is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</p>
<p>Multiplication with respect to either full/square or non-full/square <code>Q</code> is allowed, i.e. both <code>F.Q*F.R</code> and <code>F.Q*A</code> are supported. A <code>Q</code> matrix can be converted into a regular matrix with <a href="@ref"><code>Matrix</code></a>. This operation returns the “thin” Q factor, i.e., if <code>A</code> is <code>m</code>×<code>n</code> with <code>m&gt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>×<code>n</code> matrix with orthonormal columns. To retrieve the “full” Q factor, an <code>m</code>×<code>m</code> orthogonal matrix, use <code>F.Q*Matrix(I,m,m)</code>. If <code>m&lt;=n</code>, then <code>Matrix(F.Q)</code> yields an <code>m</code>×<code>m</code> orthogonal matrix.</p>
<p>The block size for QR decomposition can be specified by keyword argument <code>blocksize :: Integer</code> when <code>pivot == Val(false)</code> and <code>A isa StridedMatrix{&lt;:BlasFloat}</code>. It is ignored when <code>blocksize &gt; minimum(size(A))</code>. See <a href="@ref"><code>QRCompactWY</code></a>.</p>
<p>!!! compat “Julia 1.4”  The <code>blocksize</code> keyword argument requires Julia 1.4 or later.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3.0 -6.0; 4.0 -8.0; 0.0 1.0]
3×2 Array{Float64,2}:
 3.0  -6.0
 4.0  -8.0
 0.0   1.0

julia&gt; F = qr(A)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
3×3 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.6   0.0   0.8
 -0.8   0.0  -0.6
  0.0  -1.0   0.0
R factor:
2×2 Array{Float64,2}:
 -5.0  10.0
  0.0  -1.0

julia&gt; F.Q * F.R == A
true
</code></pre>
<p>!!! note  <code>qr</code> returns multiple types because LAPACK uses several representations that minimize the memory storage requirements of products of Householder elementary reflectors, so that the <code>Q</code> and <code>R</code> matrices can be stored compactly rather as two separate dense matrices.</p>
<pre><code>qr(A) -&gt; QRSparse
</code></pre>
<p>Compute the <code>QR</code> factorization of a sparse matrix <code>A</code>. Fill-reducing row and column permutations are used such that <code>F.R = F.Q'*A[F.prow,F.pcol]</code>. The main application of this type is to solve least squares or underdetermined problems with <a href="@ref"><code>\</code></a>. The function calls the C library SPQR.</p>
<p>!!! note  <code>qr(A::SparseMatrixCSC)</code> uses the SPQR library that is part of SuiteSparse. As this library only supports sparse matrices with <a href="@ref"><code>Float64</code></a> or <code>ComplexF64</code> elements, as of Julia v1.4 <code>qr</code> converts <code>A</code> into a copy that is of type <code>SparseMatrixCSC{Float64}</code> or <code>SparseMatrixCSC{ComplexF64}</code> as appropriate.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = sparse([1,2,3,4], [1,1,2,2], [1.0,1.0,1.0,1.0])
4×2 SparseMatrixCSC{Float64,Int64} with 4 stored entries:
  [1, 1]  =  1.0
  [2, 1]  =  1.0
  [3, 2]  =  1.0
  [4, 2]  =  1.0

julia&gt; qr(A)
Base.SparseArrays.SPQR.QRSparse{Float64,Int64}
Q factor:
4×4 Base.SparseArrays.SPQR.QRSparseQ{Float64,Int64}:
 -0.707107   0.0        0.0       -0.707107
  0.0       -0.707107  -0.707107   0.0
  0.0       -0.707107   0.707107   0.0
 -0.707107   0.0        0.0        0.707107
R factor:
2×2 SparseMatrixCSC{Float64,Int64} with 2 stored entries:
  [1, 1]  =  -1.41421
  [2, 2]  =  -1.41421
Row permutation:
4-element Array{Int64,1}:
 1
 3
 4
 2
Column permutation:
2-element Array{Int64,1}:
 1
 2
</code></pre>
<pre><code>qr(A::StaticMatrix, pivot=Val(false))
</code></pre>
<p>Compute the QR factorization of <code>A</code>. The factors can be obtain by iteration:</p>
<pre><code class="julia">julia&gt; A = @SMatrix rand(3,4);

julia&gt; Q, R = qr(A);

julia&gt; Q * R ≈ A
true
</code></pre>
<p>or by using <code>getfield</code>:</p>
<pre><code class="julia">julia&gt; F = qr(A);

julia&gt; F.Q * F.R ≈ A
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-qr.21"><h3>qr!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>qr!(A, pivot=Val(false); blocksize)
</code></pre>
<p><code>qr!</code> is the same as <a href="@ref"><code>qr</code></a> when <code>A</code> is a subtype of <a href="@ref"><code>StridedMatrix</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. An <a href="@ref"><code>InexactError</code></a> exception is thrown if the factorization produces a number not representable by the element type of <code>A</code>, e.g. for integer types.</p>
<p>!!! compat “Julia 1.4”  The <code>blocksize</code> keyword argument requires Julia 1.4 or later.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; qr!(a)
LinearAlgebra.QRCompactWY{Float64,Array{Float64,2}}
Q factor:
2×2 LinearAlgebra.QRCompactWYQ{Float64,Array{Float64,2}}:
 -0.316228  -0.948683
 -0.948683   0.316228
R factor:
2×2 Array{Float64,2}:
 -3.16228  -4.42719
  0.0      -0.632456

julia&gt; a = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; qr!(a)
ERROR: InexactError: Int64(-3.1622776601683795)
Stacktrace:
[...]
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-QRPivoted"><h3>QRPivoted</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>QRPivoted &lt;: Factorization
</code></pre>
<p>A QR matrix factorization with column pivoting in a packed format, typically obtained from <a href="@ref"><code>qr</code></a>. If $A$ is an <code>m</code>×<code>n</code> matrix, then</p>
<p>$$ A P = Q R $$</p>
<p>where $P$ is a permutation matrix, $Q$ is an orthogonal/unitary matrix and $R$ is upper triangular. The matrix $Q$ is stored as a sequence of Householder reflectors:</p>
<p>$$ Q = \prod_{i=1}^{\min(m,n)} (I - \tau_i v_i v_i^T). $$</p>
<p>Iterating the decomposition produces the components <code>Q</code>, <code>R</code>, and <code>p</code>.</p>
<p>The object has three fields:</p>
<ul>
  <li><code>factors</code> is an <code>m</code>×<code>n</code> matrix.
    <ul>
      <li>The upper triangular part contains the elements of $R$, that is <code>R = triu(F.factors)</code> for a <code>QR</code> object <code>F</code>.</li>
      <li>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix <code>V = I + tril(F.factors, -1)</code>.</li>
    </ul>
  </li>
  <li><code>τ</code> is a vector of length <code>min(m,n)</code> containing the coefficients $au_i$.</li>
  <li><code>jpvt</code> is an integer vector of length <code>n</code> corresponding to the permutation $P$.</li>
</ul></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-rank"><h3>rank</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>rank(A::AbstractMatrix; atol::Real=0, rtol::Real=atol&gt;0 ? 0 : n*ϵ)
rank(A::AbstractMatrix, rtol::Real)
</code></pre>
<p>Compute the rank of a matrix by counting how many singular values of <code>A</code> have magnitude greater than <code>max(atol, rtol*σ₁)</code> where <code>σ₁</code> is <code>A</code>’s largest singular value. <code>atol</code> and <code>rtol</code> are the absolute and relative tolerances, respectively. The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of <code>A</code>, and <code>ϵ</code> is the <a href="@ref"><code>eps</code></a> of the element type of <code>A</code>.</p>
<p>!!! compat “Julia 1.1”  The <code>atol</code> and <code>rtol</code> keyword arguments requires at least Julia 1.1. In Julia 1.0 <code>rtol</code> is available as a positional argument, but this will be deprecated in Julia 2.0.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; rank(Matrix(I, 3, 3))
3

julia&gt; rank(diagm(0 =&gt; [1, 0, 2]))
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), rtol=0.1)
2

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), rtol=0.00001)
3

julia&gt; rank(diagm(0 =&gt; [1, 0.001, 2]), atol=1.5)
1
</code></pre>
<pre><code>rank(M::Generic.MatrixElem{T}) where {T &lt;: RingElement}
</code></pre>
<p>Return the rank of the matrix $M$.</p>
<pre><code>rank(M::Generic.MatrixElem{T}) where {T &lt;: FieldElement}
</code></pre>
<p>Return the rank of the matrix $M$.</p>
<pre><code>rank(M::FreeModule{T}) where T &lt;: Union{RingElement, NCRingElem}
</code></pre>
<p>Return the rank of the given free module.</p>
<pre><code>rank(d::MatrixDistribution)
</code></pre>
<p>The rank of each sample from the distribution <code>d</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-RankDeficientException"><h3>RankDeficientException</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>No documentation found.</p>
<h1><a href="#summary" name="summary"></a>Summary</h1>
<pre><code>struct LinearAlgebra.RankDeficientException &lt;: Exception
</code></pre>
<h1><a href="#fields" name="fields"></a>Fields</h1>
<pre><code>info :: Int64
</code></pre>
<h1><a href="#supertype-hierarchy" name="supertype-hierarchy"></a>Supertype Hierarchy</h1>
<pre><code>LinearAlgebra.RankDeficientException &lt;: Exception &lt;: Any
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-rdiv.21"><h3>rdiv!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>rdiv!(A, B)
</code></pre>
<p>Compute <code>A / B</code> in-place and overwriting <code>A</code> to store the result.</p>
<p>The argument <code>B</code> should <em>not</em> be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by <a href="@ref"><code>factorize</code></a> or <a href="@ref"><code>cholesky</code></a>). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., <a href="@ref"><code>lu!</code></a>), and performance-critical situations requiring <code>rdiv!</code> usually also require fine-grained control over the factorization of <code>B</code>.</p>
<pre><code>rdiv!(A::AbstractArray, b::Number)
</code></pre>
<p>Divide each entry in an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place. Use <a href="@ref"><code>ldiv!</code></a> to divide scalar from left.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1.0 2.0; 3.0 4.0]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; rdiv!(A, 2.0)
2×2 Array{Float64,2}:
 0.5  1.0
 1.5  2.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-reflect.21"><h3>reflect!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>reflect!(x, y, c, s)
</code></pre>
<p>Overwrite <code>x</code> with <code>c*x + s*y</code> and <code>y</code> with <code>conj(s)*x - c*y</code>. Returns <code>x</code> and <code>y</code>.</p>
<p>!!! compat “Julia 1.5”  <code>reflect!</code> requires at least Julia 1.5.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-rmul.21"><h3>rmul!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>rmul!(A::AbstractArray, b::Number)
</code></pre>
<p>Scale an array <code>A</code> by a scalar <code>b</code> overwriting <code>A</code> in-place. Use <a href="@ref"><code>lmul!</code></a> to multiply scalar from left. The scaling operation respects the semantics of the multiplication <a href="@ref"><code>*</code></a> between an element of <code>A</code> and <code>b</code>. In particular, this also applies to multiplication involving non-finite numbers such as <code>NaN</code> and <code>±Inf</code>.</p>
<p>!!! compat “Julia 1.1”  Prior to Julia 1.1, <code>NaN</code> and <code>±Inf</code> entries in <code>A</code> were treated inconsistently.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; rmul!(A, 2)
2×2 Array{Int64,2}:
 2  4
 6  8

julia&gt; rmul!([NaN], 0.0)
1-element Array{Float64,1}:
 NaN
</code></pre>
<pre><code>rmul!(A, B)
</code></pre>
<p>Calculate the matrix-matrix product $AB$, overwriting <code>A</code>, and return the result. Here, <code>B</code> must be of special matrix type, like, e.g., <a href="@ref"><code>Diagonal</code></a>, <a href="@ref"><code>UpperTriangular</code></a> or <a href="@ref"><code>LowerTriangular</code></a>, or of some orthogonal type, see <a href="@ref"><code>QR</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [0 1; 1 0];

julia&gt; B = LinearAlgebra.UpperTriangular([1 2; 0 3]);

julia&gt; LinearAlgebra.rmul!(A, B);

julia&gt; A
2×2 Array{Int64,2}:
 0  3
 1  2

julia&gt; A = [1.0 2.0; 3.0 4.0];

julia&gt; F = qr([0 1; -1 0]);

julia&gt; rmul!(A, F.Q)
2×2 Array{Float64,2}:
 2.0  1.0
 4.0  3.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-rotate.21"><h3>rotate!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>rotate!(x, y, c, s)
</code></pre>
<p>Overwrite <code>x</code> with <code>c*x + s*y</code> and <code>y</code> with <code>-conj(s)*x + c*y</code>. Returns <code>x</code> and <code>y</code>.</p>
<p>!!! compat “Julia 1.5”  <code>rotate!</code> requires at least Julia 1.5.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Schur"><h3>Schur</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Schur &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the Schur factorization of a matrix <code>A</code>. This is the return type of <a href="@ref"><code>schur(_)</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>F::Schur</code> is the factorization object, the (quasi) triangular Schur factor can be obtained via either <code>F.Schur</code> or <code>F.T</code> and the orthogonal/unitary Schur vectors via <code>F.vectors</code> or <code>F.Z</code> such that <code>A = F.vectors * F.Schur * F.vectors'</code>. The eigenvalues of <code>A</code> can be obtained with <code>F.values</code>.</p>
<p>Iterating the decomposition produces the components <code>F.T</code>, <code>F.Z</code>, and <code>F.values</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # destructuring via iteration

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-schur"><h3>schur</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>schur(A::StridedMatrix) -&gt; F::Schur
</code></pre>
<p>Computes the Schur factorization of the matrix <code>A</code>. The (quasi) triangular Schur factor can be obtained from the <code>Schur</code> object <code>F</code> with either <code>F.Schur</code> or <code>F.T</code> and the orthogonal/unitary Schur vectors can be obtained with <code>F.vectors</code> or <code>F.Z</code> such that <code>A = F.vectors * F.Schur * F.vectors'</code>. The eigenvalues of <code>A</code> can be obtained with <code>F.values</code>.</p>
<p>Iterating the decomposition produces the components <code>F.T</code>, <code>F.Z</code>, and <code>F.values</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; F.vectors * F.Schur * F.vectors'
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; t, z, vals = F; # destructuring via iteration

julia&gt; t == F.T &amp;&amp; z == F.Z &amp;&amp; vals == F.values
true
</code></pre>
<pre><code>schur(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur
</code></pre>
<p>Computes the Generalized Schur (or QZ) factorization of the matrices <code>A</code> and <code>B</code>. The (quasi) triangular Schur factors can be obtained from the <code>Schur</code> object <code>F</code> with <code>F.S</code> and <code>F.T</code>, the left unitary/orthogonal Schur vectors can be obtained with <code>F.left</code> or <code>F.Q</code> and the right unitary/orthogonal Schur vectors can be obtained with <code>F.right</code> or <code>F.Z</code> such that <code>A=F.left*F.S*F.right'</code> and <code>B=F.left*F.T*F.right'</code>. The generalized eigenvalues of <code>A</code> and <code>B</code> can be obtained with <code>F.α./F.β</code>.</p>
<p>Iterating the decomposition produces the components <code>F.S</code>, <code>F.T</code>, <code>F.Q</code>, <code>F.Z</code>, <code>F.α</code>, and <code>F.β</code>.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-schur.21"><h3>schur!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>schur!(A::StridedMatrix) -&gt; F::Schur
</code></pre>
<p>Same as <a href="@ref"><code>schur</code></a> but uses the input argument <code>A</code> as workspace.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [5. 7.; -2. -4.]
2×2 Array{Float64,2}:
  5.0   7.0
 -2.0  -4.0

julia&gt; F = schur!(A)
Schur{Float64,Array{Float64,2}}
T factor:
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
Z factor:
2×2 Array{Float64,2}:
  0.961524  0.274721
 -0.274721  0.961524
eigenvalues:
2-element Array{Float64,1}:
  3.0
 -2.0

julia&gt; A
2×2 Array{Float64,2}:
 3.0   9.0
 0.0  -2.0
</code></pre>
<pre><code>schur!(A::StridedMatrix, B::StridedMatrix) -&gt; F::GeneralizedSchur
</code></pre>
<p>Same as <a href="@ref"><code>schur</code></a> but uses the input matrices <code>A</code> and <code>B</code> as workspace.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-SingularException"><h3>SingularException</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>SingularException
</code></pre>
<p>Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The <code>info</code> field indicates the location of (one of) the singular value(s).</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-SVD"><h3>SVD</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>SVD &lt;: Factorization
</code></pre>
<p>Matrix factorization type of the singular value decomposition (SVD) of a matrix <code>A</code>. This is the return type of <a href="@ref"><code>svd(_)</code></a>, the corresponding matrix factorization function.</p>
<p>If <code>F::SVD</code> is the factorization object, <code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained via <code>F.U</code>, <code>F.S</code>, <code>F.V</code> and <code>F.Vt</code>, such that <code>A = U * Diagonal(S) * Vt</code>. The singular values in <code>S</code> are sorted in descending order.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>S</code>, and <code>V</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; F = svd(A)
SVD{Float64,Float64,Array{Float64,2}}
U factor:
4×4 Array{Float64,2}:
 0.0  1.0  0.0   0.0
 1.0  0.0  0.0   0.0
 0.0  0.0  0.0  -1.0
 0.0  0.0  1.0   0.0
singular values:
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
Vt factor:
4×5 Array{Float64,2}:
 -0.0       0.0  1.0  -0.0  0.0
  0.447214  0.0  0.0   0.0  0.894427
 -0.0       1.0  0.0  -0.0  0.0
  0.0       0.0  0.0   1.0  0.0

julia&gt; F.U * Diagonal(F.S) * F.Vt
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; u, s, v = F; # destructuring via iteration

julia&gt; u == F.U &amp;&amp; s == F.S &amp;&amp; v == F.V
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-svd"><h3>svd</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -&gt; SVD
</code></pre>
<p>Compute the singular value decomposition (SVD) of <code>A</code> and return an <code>SVD</code> object.</p>
<p><code>U</code>, <code>S</code>, <code>V</code> and <code>Vt</code> can be obtained from the factorization <code>F</code> with <code>F.U</code>, <code>F.S</code>, <code>F.V</code> and <code>F.Vt</code>, such that <code>A = U * Diagonal(S) * Vt</code>. The algorithm produces <code>Vt</code> and hence <code>Vt</code> is more efficient to extract than <code>V</code>. The singular values in <code>S</code> are sorted in descending order.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>S</code>, and <code>V</code>.</p>
<p>If <code>full = false</code> (default), a “thin” SVD is returned. For a $M \times N$ matrix <code>A</code>, in the full factorization <code>U</code> is <code>M \times M</code> and <code>V</code> is <code>N \times N</code>, while in the thin factorization <code>U</code> is <code>M \times K</code> and <code>V</code> is <code>N \times K</code>, where <code>K = \min(M,N)</code> is the number of singular values.</p>
<p>If <code>alg = DivideAndConquer()</code> a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is <code>alg = QRIteration()</code>.</p>
<p>!!! compat “Julia 1.3”  The <code>alg</code> keyword argument requires Julia 1.3 or later.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = rand(4,3);

julia&gt; F = svd(A); # Store the Factorization Object

julia&gt; A ≈ F.U * Diagonal(F.S) * F.Vt
true

julia&gt; U, S, V = F; # destructuring via iteration

julia&gt; A ≈ U * Diagonal(S) * V'
true

julia&gt; Uonly, = svd(A); # Store U only

julia&gt; Uonly == U
true
</code></pre>
<pre><code>svd(A, B) -&gt; GeneralizedSVD
</code></pre>
<p>Compute the generalized SVD of <code>A</code> and <code>B</code>, returning a <code>GeneralizedSVD</code> factorization object <code>F</code> such that <code>[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'</code></p>
<ul>
  <li><code>U</code> is a M-by-M orthogonal matrix,</li>
  <li><code>V</code> is a P-by-P orthogonal matrix,</li>
  <li><code>Q</code> is a N-by-N orthogonal matrix,</li>
  <li><code>D1</code> is a M-by-(K+L) diagonal matrix with 1s in the first K entries,</li>
  <li><code>D2</code> is a P-by-(K+L) matrix whose top right L-by-L block is diagonal,</li>
  <li><code>R0</code> is a (K+L)-by-N matrix whose rightmost (K+L)-by-(K+L) block is nonsingular upper block triangular,</li>
</ul>
<p><code>K+L</code> is the effective numerical rank of the matrix <code>[A; B]</code>.</p>
<p>Iterating the decomposition produces the components <code>U</code>, <code>V</code>, <code>Q</code>, <code>D1</code>, <code>D2</code>, and <code>R0</code>.</p>
<p>The generalized SVD is used in applications such as when one wants to compare how much belongs to <code>A</code> vs. how much belongs to <code>B</code>, as in human vs yeast genome, or signal vs noise, or between clusters vs within clusters. (See Edelman and Wang for discussion: <a href="https://arxiv.org/abs/1901.00485">https://arxiv.org/abs/1901.00485</a>)</p>
<p>It decomposes <code>[A; B]</code> into <code>[UC; VS]H</code>, where <code>[UC; VS]</code> is a natural orthogonal basis for the column space of <code>[A; B]</code>, and <code>H = RQ'</code> is a natural non-orthogonal basis for the rowspace of <code>[A;B]</code>, where the top rows are most closely attributed to the <code>A</code> matrix, and the bottom to the <code>B</code> matrix. The multi-cosine/sine matrices <code>C</code> and <code>S</code> provide a multi-measure of how much <code>A</code> vs how much <code>B</code>, and <code>U</code> and <code>V</code> provide directions in which these are measured.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = randn(3,2); B=randn(4,2);

julia&gt; F = svd(A, B);

julia&gt; U,V,Q,C,S,R = F;

julia&gt; H = R*Q';

julia&gt; [A; B] ≈ [U*C; V*S]*H
true

julia&gt; [A; B] ≈ [F.U*F.D1; F.V*F.D2]*F.R0*F.Q'
true

julia&gt; Uonly, = svd(A,B);

julia&gt; U == Uonly
true
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-svd.21"><h3>svd!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -&gt; SVD
</code></pre>
<p><code>svd!</code> is the same as <a href="@ref"><code>svd</code></a>, but saves space by overwriting the input <code>A</code>, instead of creating a copy. See documentation of <a href="@ref"><code>svd</code></a> for details. ```</p>
<pre><code>svd!(A, B) -&gt; GeneralizedSVD
</code></pre>
<p><code>svd!</code> is the same as <a href="@ref"><code>svd</code></a>, but modifies the arguments <code>A</code> and <code>B</code> in-place, instead of making copies. See documentation of <a href="@ref"><code>svd</code></a> for details. ```</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-svdvals"><h3>svdvals</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>svdvals(A)
</code></pre>
<p>Return the singular values of <code>A</code> in descending order.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]
4×5 Array{Float64,2}:
 1.0  0.0  0.0  0.0  2.0
 0.0  0.0  3.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0
 0.0  2.0  0.0  0.0  0.0

julia&gt; svdvals(A)
4-element Array{Float64,1}:
 3.0
 2.23606797749979
 2.0
 0.0
</code></pre>
<pre><code>svdvals(A, B)
</code></pre>
<p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>. See also <a href="@ref"><code>svd</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1. 0.; 0. -1.]
2×2 Array{Float64,2}:
 1.0   0.0
 0.0  -1.0

julia&gt; B = [0. 1.; 1. 0.]
2×2 Array{Float64,2}:
 0.0  1.0
 1.0  0.0

julia&gt; svdvals(A, B)
2-element Array{Float64,1}:
 1.0
 1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-svdvals.21"><h3>svdvals!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>svdvals!(A)
</code></pre>
<p>Return the singular values of <code>A</code>, saving space by overwriting the input. See also <a href="@ref"><code>svdvals</code></a> and <a href="@ref"><code>svd</code></a>. ```</p>
<pre><code>svdvals!(A, B)
</code></pre>
<p>Return the generalized singular values from the generalized singular value decomposition of <code>A</code> and <code>B</code>, saving space by overwriting <code>A</code> and <code>B</code>. See also <a href="@ref"><code>svd</code></a> and <a href="@ref"><code>svdvals</code></a>. ```</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-sylvester"><h3>sylvester</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>sylvester(A, B, C)
</code></pre>
<p>Computes the solution <code>X</code> to the Sylvester equation <code>AX + XB + C = 0</code>, where <code>A</code>, <code>B</code> and <code>C</code> have compatible dimensions and <code>A</code> and <code>-B</code> have no eigenvalues with equal real part.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3. 4.; 5. 6]
2×2 Array{Float64,2}:
 3.0  4.0
 5.0  6.0

julia&gt; B = [1. 1.; 1. 2.]
2×2 Array{Float64,2}:
 1.0  1.0
 1.0  2.0

julia&gt; C = [1. 2.; -2. 1]
2×2 Array{Float64,2}:
  1.0  2.0
 -2.0  1.0

julia&gt; X = sylvester(A, B, C)
2×2 Array{Float64,2}:
 -4.46667   1.93333
  3.73333  -1.8

julia&gt; A*X + X*B + C
2×2 Array{Float64,2}:
  2.66454e-15  1.77636e-15
 -3.77476e-15  4.44089e-16
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Symmetric"><h3>Symmetric</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Symmetric(A, uplo=:U)
</code></pre>
<p>Construct a <code>Symmetric</code> view of the upper (if <code>uplo = :U</code>) or lower (if <code>uplo = :L</code>) triangle of the matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 0 2 0 3; 0 4 0 5 0; 6 0 7 0 8; 0 9 0 1 0; 2 0 3 0 4]
5×5 Array{Int64,2}:
 1  0  2  0  3
 0  4  0  5  0
 6  0  7  0  8
 0  9  0  1  0
 2  0  3  0  4

julia&gt; Supper = Symmetric(A)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  2  0  3
 0  4  0  5  0
 2  0  7  0  8
 0  5  0  1  0
 3  0  8  0  4

julia&gt; Slower = Symmetric(A, :L)
5×5 Symmetric{Int64,Array{Int64,2}}:
 1  0  6  0  2
 0  4  0  9  0
 6  0  7  0  3
 0  9  0  1  0
 2  0  3  0  4
</code></pre>
<p>Note that <code>Supper</code> will not be equal to <code>Slower</code> unless <code>A</code> is itself symmetric (e.g. if <code>A == transpose(A)</code>).</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-SymTridiagonal"><h3>SymTridiagonal</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>SymTridiagonal(dv::V, ev::V) where V &lt;: AbstractVector
</code></pre>
<p>Construct a symmetric tridiagonal matrix from the diagonal (<code>dv</code>) and first sub/super-diagonal (<code>ev</code>), respectively. The result is of type <code>SymTridiagonal</code> and provides efficient specialized eigensolvers, but may be converted into a regular matrix with <a href="@ref"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p>
<p>For <code>SymTridiagonal</code> block matrices, the elements of <code>dv</code> are symmetrized. The argument <code>ev</code> is interpreted as the superdiagonal. Blocks from the subdiagonal are (materialized) transpose of the corresponding superdiagonal blocks.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; dv = [1, 2, 3, 4]
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; ev = [7, 8, 9]
3-element Array{Int64,1}:
 7
 8
 9

julia&gt; SymTridiagonal(dv, ev)
4×4 SymTridiagonal{Int64,Array{Int64,1}}:
 1  7  ⋅  ⋅
 7  2  8  ⋅
 ⋅  8  3  9
 ⋅  ⋅  9  4

julia&gt; A = SymTridiagonal(fill([1 2; 3 4], 3), fill([1 2; 3 4], 2));

julia&gt; A[1,1]
2×2 Symmetric{Int64,Array{Int64,2}}:
 1  2
 2  4

julia&gt; A[1,2]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; A[2,1]
2×2 Array{Int64,2}:
 1  3
 2  4
</code></pre>
<pre><code>SymTridiagonal(A::AbstractMatrix)
</code></pre>
<p>Construct a symmetric tridiagonal matrix from the diagonal and first superdiagonal of the symmetric matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3; 2 4 5; 3 5 6]
3×3 Array{Int64,2}:
 1  2  3
 2  4  5
 3  5  6

julia&gt; SymTridiagonal(A)
3×3 SymTridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅
 2  4  5
 ⋅  5  6

julia&gt; B = reshape([[1 2; 2 3], [1 2; 3 4], [1 3; 2 4], [1 2; 2 3]], 2, 2);

julia&gt; SymTridiagonal(B)
2×2 SymTridiagonal{Array{Int64,2},Array{Array{Int64,2},1}}:
 [1 2; 2 3]  [1 3; 2 4]
 [1 2; 3 4]  [1 2; 2 3]
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-tr"><h3>tr</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>tr(M)
</code></pre>
<p>Matrix trace. Sums the diagonal elements of <code>M</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; tr(A)
5
</code></pre>
<pre><code>tr(x::Generic.MatrixElem)
</code></pre>
<p>Return the trace of the matrix $a$, i.e. the sum of the diagonal elements. We require the matrix to be square.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Transpose"><h3>Transpose</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Transpose
</code></pre>
<p>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an <code>AbstractVector</code>/<code>AbstractMatrix</code>, but also some <code>Factorization</code>, for instance. Usually, the <code>Transpose</code> constructor should not be called directly, use <a href="@ref"><code>transpose</code></a> instead. To materialize the view use <a href="@ref"><code>copy</code></a>.</p>
<p>This type is intended for linear algebra usage - for general data manipulation see [<code>permutedims</code>](@ref Base.permutedims).</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-transpose"><h3>transpose</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>transpose(A)
</code></pre>
<p>Lazy transpose. Mutating the returned object should appropriately mutate <code>A</code>. Often, but not always, yields <code>Transpose(A)</code>, where <code>Transpose</code> is a lazy transpose wrapper. Note that this operation is recursive.</p>
<p>This operation is intended for linear algebra usage - for general data manipulation see [<code>permutedims</code>](@ref Base.permutedims), which is non-recursive.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; transpose(A)
2×2 Transpose{Complex{Int64},Array{Complex{Int64},2}}:
 3+2im  8+7im
 9+2im  4+6im
</code></pre>
<pre><code>transpose(x::Mat)
</code></pre>
<p>Return the transpose of the given matrix.</p>
<pre><code>transpose(x::MatAlgElem{T}) where T &lt;: RingElement
</code></pre>
<p>Return the transpose of the given matrix.</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-transpose.21"><h3>transpose!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>transpose!(dest,src)
</code></pre>
<p>Transpose array <code>src</code> and store the result in the preallocated array <code>dest</code>, which should have a size corresponding to <code>(size(src,2),size(src,1))</code>. No in-place transposition is supported and unexpected results will happen if <code>src</code> and <code>dest</code> have overlapping memory regions.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [3+2im 9+2im; 8+7im  4+6im]
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im

julia&gt; B = zeros(Complex{Int64}, 2, 2)
2×2 Array{Complex{Int64},2}:
 0+0im  0+0im
 0+0im  0+0im

julia&gt; transpose!(B, A);

julia&gt; B
2×2 Array{Complex{Int64},2}:
 3+2im  8+7im
 9+2im  4+6im

julia&gt; A
2×2 Array{Complex{Int64},2}:
 3+2im  9+2im
 8+7im  4+6im
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-Tridiagonal"><h3>Tridiagonal</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>Tridiagonal(dl::V, d::V, du::V) where V &lt;: AbstractVector
</code></pre>
<p>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type <code>Tridiagonal</code> and provides efficient specialized linear solvers, but may be converted into a regular matrix with <a href="@ref"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short). The lengths of <code>dl</code> and <code>du</code> must be one less than the length of <code>d</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; dl = [1, 2, 3];

julia&gt; du = [4, 5, 6];

julia&gt; d = [7, 8, 9, 0];

julia&gt; Tridiagonal(dl, d, du)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 7  4  ⋅  ⋅
 1  8  5  ⋅
 ⋅  2  9  6
 ⋅  ⋅  3  0
</code></pre>
<pre><code>Tridiagonal(A)
</code></pre>
<p>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3 4; 1 2 3 4; 1 2 3 4; 1 2 3 4]
4×4 Array{Int64,2}:
 1  2  3  4
 1  2  3  4
 1  2  3  4
 1  2  3  4

julia&gt; Tridiagonal(A)
4×4 Tridiagonal{Int64,Array{Int64,1}}:
 1  2  ⋅  ⋅
 1  2  3  ⋅
 ⋅  2  3  4
 ⋅  ⋅  3  4
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-tril"><h3>tril</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>tril(M)
</code></pre>
<p>Lower triangle of a matrix.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a)
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 1.0  1.0  0.0  0.0
 1.0  1.0  1.0  0.0
 1.0  1.0  1.0  1.0
</code></pre>
<pre><code>tril(M, k::Integer)
</code></pre>
<p>Returns the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; tril(a,-3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-tril.21"><h3>tril!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>tril!(M)
</code></pre>
<p>Lower triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="@ref"><code>tril</code></a>.</p>
<pre><code>tril!(M, k::Integer)
</code></pre>
<p>Return the lower triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; tril!(M, 2)
5×5 Array{Int64,2}:
 1  2  3  0  0
 1  2  3  4  0
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-triu"><h3>triu</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>triu(M)
</code></pre>
<p>Upper triangle of a matrix.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 0.0  1.0  1.0  1.0
 0.0  0.0  1.0  1.0
 0.0  0.0  0.0  1.0
</code></pre>
<pre><code>triu(M, k::Integer)
</code></pre>
<p>Returns the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; a = fill(1.0, (4,4))
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0

julia&gt; triu(a,3)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0

julia&gt; triu(a,-3)
4×4 Array{Float64,2}:
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
 1.0  1.0  1.0  1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-triu.21"><h3>triu!</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>triu!(M)
</code></pre>
<p>Upper triangle of a matrix, overwriting <code>M</code> in the process. See also <a href="@ref"><code>triu</code></a>.</p>
<pre><code>triu!(M, k::Integer)
</code></pre>
<p>Return the upper triangle of <code>M</code> starting from the <code>k</code>th superdiagonal, overwriting <code>M</code> in the process.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; M = [1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5; 1 2 3 4 5]
5×5 Array{Int64,2}:
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5
 1  2  3  4  5

julia&gt; triu!(M, 1)
5×5 Array{Int64,2}:
 0  2  3  4  5
 0  0  3  4  5
 0  0  0  4  5
 0  0  0  0  5
 0  0  0  0  0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-UniformScaling"><h3>UniformScaling</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UniformScaling{T&lt;:Number}
</code></pre>
<p>Generically sized uniform scaling operator defined as a scalar times the identity operator, <code>λ*I</code>. See also <a href="@ref"><code>I</code></a>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; J = UniformScaling(2.)
UniformScaling{Float64}
2.0*I

julia&gt; A = [1. 2.; 3. 4.]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; J*A
2×2 Array{Float64,2}:
 2.0  4.0
 6.0  8.0
</code></pre>
<pre><code>(I::UniformScaling)(n::Integer)
</code></pre>
<p>Construct a <code>Diagonal</code> matrix from a <code>UniformScaling</code>.</p>
<p>!!! compat “Julia 1.2”  This method is available as of Julia 1.2.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; I(3)
3×3 Diagonal{Bool,Array{Bool,1}}:
 1  ⋅  ⋅
 ⋅  1  ⋅
 ⋅  ⋅  1

julia&gt; (0.7*I)(3)
3×3 Diagonal{Float64,Array{Float64,1}}:
 0.7   ⋅    ⋅
  ⋅   0.7   ⋅
  ⋅    ⋅   0.7
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-UnitLowerTriangular"><h3>UnitLowerTriangular</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UnitLowerTriangular(A::AbstractMatrix)
</code></pre>
<p>Construct a <code>UnitLowerTriangular</code> view of the matrix <code>A</code>. Such a view has the <a href="@ref"><code>oneunit</code></a> of the <a href="@ref"><code>eltype</code></a> of <code>A</code> on its diagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UnitLowerTriangular(A)
3×3 UnitLowerTriangular{Float64,Array{Float64,2}}:
 1.0   ⋅    ⋅
 4.0  1.0   ⋅
 7.0  8.0  1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-UnitUpperTriangular"><h3>UnitUpperTriangular</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UnitUpperTriangular(A::AbstractMatrix)
</code></pre>
<p>Construct an <code>UnitUpperTriangular</code> view of the matrix <code>A</code>. Such a view has the <a href="@ref"><code>oneunit</code></a> of the <a href="@ref"><code>eltype</code></a> of <code>A</code> on its diagonal.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UnitUpperTriangular(A)
3×3 UnitUpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   1.0  6.0
  ⋅    ⋅   1.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-UpperHessenberg"><h3>UpperHessenberg</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UpperHessenberg(A::AbstractMatrix)
</code></pre>
<p>Construct an <code>UpperHessenberg</code> view of the matrix <code>A</code>. Entries of <code>A</code> below the first subdiagonal are ignored.</p>
<p>Efficient algorithms are implemented for <code>H \ b</code>, <code>det(H)</code>, and similar.</p>
<p>See also the <a href="@ref"><code>hessenberg</code></a> function to factor any matrix into a similar upper-Hessenberg matrix.</p>
<p>If <code>F::Hessenberg</code> is the factorization object, the unitary matrix can be accessed with <code>F.Q</code> and the Hessenberg matrix with <code>F.H</code>. When <code>Q</code> is extracted, the resulting type is the <code>HessenbergQ</code> object, and may be converted to a regular matrix with <a href="@ref"><code>convert(Array, _)</code></a> (or <code>Array(_)</code> for short).</p>
<p>Iterating the decomposition produces the factors <code>F.Q</code> and <code>F.H</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
4×4 Array{Int64,2}:
  1   2   3   4
  5   6   7   8
  9  10  11  12
 13  14  15  16

julia&gt; UpperHessenberg(A)
4×4 UpperHessenberg{Int64,Array{Int64,2}}:
 1   2   3   4
 5   6   7   8
 ⋅  10  11  12
 ⋅   ⋅  15  16
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-UpperTriangular"><h3>UpperTriangular</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>UpperTriangular(A::AbstractMatrix)
</code></pre>
<p>Construct an <code>UpperTriangular</code> view of the matrix <code>A</code>.</p>
<h1><a href="#examples" name="examples"></a>Examples</h1>
<pre><code class="jldoctest">julia&gt; A = [1.0 2.0 3.0; 4.0 5.0 6.0; 7.0 8.0 9.0]
3×3 Array{Float64,2}:
 1.0  2.0  3.0
 4.0  5.0  6.0
 7.0  8.0  9.0

julia&gt; UpperTriangular(A)
3×3 UpperTriangular{Float64,Array{Float64,2}}:
 1.0  2.0  3.0
  ⋅   5.0  6.0
  ⋅    ⋅   9.0
</code></pre></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div><div class="public anchor" id="var-ZeroPivotException"><h3>ZeroPivotException</h3><div class="usage"></div><div class="doc"><div class="markdown"><pre><code>ZeroPivotException &lt;: Exception
</code></pre>
<p>Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed. This may <em>not</em> mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The <code>info</code> field indicates the location of (one of) the zero pivot(s).</p></div></div><div class="src-link"><a href="https://github.com/cnuernber/libjulia-clj/blob/master/src/libjulia_clj/modules/LinearAlgebra.clj#L9">view source</a></div></div></div></body></html>